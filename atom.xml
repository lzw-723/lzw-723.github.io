<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://blog.lzw-723.xyz</id>
    <title>lzw-723&apos;s blog</title>
    <updated>2021-08-06T01:50:25.074Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://blog.lzw-723.xyz"/>
    <link rel="self" href="https://blog.lzw-723.xyz/atom.xml"/>
    <subtitle>要玩就玩得开心，这不代表我放弃</subtitle>
    <logo>https://blog.lzw-723.xyz/images/avatar.png</logo>
    <icon>https://blog.lzw-723.xyz/favicon.ico</icon>
    <rights>All rights reserved 2021, lzw-723&apos;s blog</rights>
    <entry>
        <title type="html"><![CDATA[C语言教程 - 变量和类型]]></title>
        <id>https://blog.lzw-723.xyz/post/c-yu-yan-jiao-cheng-bian-liang-he-lei-xing/</id>
        <link href="https://blog.lzw-723.xyz/post/c-yu-yan-jiao-cheng-bian-liang-he-lei-xing/">
        </link>
        <updated>2021-08-06T01:46:08.000Z</updated>
        <summary type="html"><![CDATA[<p>C语言有很多种类型的变量，但只有几个基本类型。</p>
]]></summary>
        <content type="html"><![CDATA[<p>C语言有很多种类型的变量，但只有几个基本类型。</p>
<!-- more -->
<h2 id="tutorial">Tutorial</h2>
<h3 id="数据类型">数据类型</h3>
<p>C语言有很多种类型的变量，但只有几个基本类型。</p>
<ul>
<li>整数——可以是正数或负数的整数。使用<code>char</code>、<code>int</code>、<code>short</code>、<code>long</code>或<code>long long</code>来定义。</li>
<li>无符号整数——只能是正数的整数。使用<code>unsigned char</code>、<code>unsigned int</code>、<code>unsigned short</code>、<code>unsigned long</code>或<code>unsigned long long</code>定义。</li>
<li>浮点数——实数（带小数的数字）。使用<code>float</code>和<code>double</code>来定义。</li>
<li>结构——将在后面的结构部分解释。</li>
</ul>
<p>不同类型的变量定义了它们的界限。一个<code>char</code>的范围只能从-128到127，而一个<code>long</code>的范围可以从-2,147,483,648到2,147,483,647（<code>long</code>和其他数字数据类型在不同的计算机上可能有另一个范围，例如——在64位计算机上从-9,223,372,036,854,775,808到9,223,372,036,854,775,807）。</p>
<p>请注意，C语言<em>没有</em>布尔类型。通常情况下，它是用下面的符号定义的。</p>
<pre><code>#define BOOL char
#define FALSE 0
#define TRUE 1
</code></pre>
<p>C语言使用字符数组来定义字符串，将在<code>字符串</code>部分进行解释。</p>
<h3 id="定义变量">定义变量</h3>
<p>通常使用<code>int</code>类型定义数字，它是一个<code>字</code>大小的整数，也就是程序的编译机器的默认数字大小。<br>
在今天的大多数计算机上，它是一个32位的数字，这意味着数字的范围可以从-2,147,483,648到2,147,483,647。</p>
<p>为了定义变量<code>foo</code>和<code>bar</code>，需要使用以下语法。</p>
<pre><code>int foo;
int bar = 1;
</code></pre>
<p>变量<code>foo</code>可以使用，但由于没有初始化它，我们不知道里面有什么。变量<code>bar</code>装着数字1。</p>
<p>现在，可以做一些数学运算。<br>
假设<code>a</code>、<code>b</code>、<code>c</code>、<code>d</code>和<code>e</code>是变量，可以简单地使用加、减和乘法运算符 在下面的代码中，给<code>a</code>分配一个新值：</p>
<pre><code>int a = 0, b = 1, c = 2, d = 3, e = 4;
a = b - c + d * e;
printf(&quot;%d&quot;, a); /* will print 1-2+3*4 = 11 */
</code></pre>
<h2 id="exercise">Exercise</h2>
<p>在下一个练习中，你将创建一个程序，打印出数字<code>a</code>、<code>b</code>和<code>c</code>的和。</p>
<h2 id="tutorial-code">Tutorial Code</h2>
<pre><code>#include &lt;stdio.h&gt;

int main() {
  int a = 3;
  float b = 4.5;
  double c = 5.25;
  float sum;

  /* 你的代码放在这里 */

  printf(&quot;The sum of a, b, and c is %f.&quot;, sum);
  return 0;
}
</code></pre>
<h2 id="expected-output">Expected Output</h2>
<pre><code>The sum of a, b, and c is 12.750000.
</code></pre>
<h2 id="solution">Solution</h2>
<pre><code>#include &lt;stdio.h&gt;

int main() {
  int a = 3;
  float b = 4.5;
  double c = 5.25;
  float sum;

  sum = a + b + c;

  printf(&quot;The sum of a, b, and c is %f.&quot;, sum);
  return 0;
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[C语言教程 - 你好，世界！]]></title>
        <id>https://blog.lzw-723.xyz/post/c-yu-yan-jiao-cheng-ni-hao-shi-jie/</id>
        <link href="https://blog.lzw-723.xyz/post/c-yu-yan-jiao-cheng-ni-hao-shi-jie/">
        </link>
        <updated>2021-08-06T01:06:56.000Z</updated>
        <summary type="html"><![CDATA[<p>虽然C语言被认为 &quot;难学&quot;，实际上C语言是一种非常简单的语言，功能强大。</p>
]]></summary>
        <content type="html"><![CDATA[<p>虽然C语言被认为 &quot;难学&quot;，实际上C语言是一种非常简单的语言，功能强大。</p>
<!-- more -->
<h2 id="tutorial">Tutorial</h2>
<h3 id="导言">导言</h3>
<p>C语言是一种通用的编程语言，它与机器的工作方式密切相关。<br>
理解计算机内存的工作方式是C语言编程的一个重要方面。<br>
虽然C语言被认为 &quot;难学&quot;，实际上C语言是一种非常简单的语言，功能强大。</p>
<p>C语言是一种非常常见的编程语言，它是许多应用程序的开发语言，如Windows、Python解释器、Git和许多其他编程语言。</p>
<p>C语言是一种编译语言——这意味着为了运行它，编译器（例如GCC或Visual Studio）必须将编写的代码进行处理，然后创建一个可执行文件。这个文件可以被执行，会做我们想让程序做的事情。</p>
<h3 id="第一个程序">第一个程序</h3>
<p>每个C语言程序都使用库，它赋予执行必要功能的能力。例如，最基本的函数<code>printf</code>，用于向屏幕打印输出，定义在 <code>stdio.h</code>头文件中。</p>
<p>为了在程序中增加运行<code>printf</code>命令的能力，必须在第一行代码中添加以下include指令。</p>
<pre><code>#include &lt;stdio.h&gt;
</code></pre>
<p>代码的第二部分是要写的实际代码。将要运行的第一段代码将始终在<code>main</code>函数中。</p>
<pre><code>int main() {
  ...你的代码放在这里
}
</code></pre>
<p><code>int</code>关键字表示函数<code>main</code>将返回一个整数——一个简单的数字。该函数返回的数字表明编写的程序是否正常工作。<br>
如果想表达代码运行成功，将返回数字0。一个大于0的数字将意味着编写的程序运行失败。</p>
<p>在本教程中，将返回0以表示程序是成功的：</p>
<pre><code>return 0;
</code></pre>
<p>请注意，C语言中的每个语句都必须以分号结束，这样编译器才知道一个新的语句已经开始。</p>
<p>最后不能不提，需要调用<code>printf</code>函数来打印句子。</p>
<h2 id="exercise">Exercise</h2>
<p>改写下面的程序，使其打印输出<code>Hello, World!</code>。</p>
<h2 id="tutorial-code">Tutorial Code</h2>
<pre><code>#include &lt;stdio.h&gt;

int main() {
  printf(&quot;Goodbye, World!&quot;);
  return 0;
}
</code></pre>
<h2 id="expected-output">Expected Output</h2>
<pre><code>Hello, World!
</code></pre>
<h2 id="solution">Solution</h2>
<pre><code>#include &lt;stdio.h&gt;

int main() {
  printf(&quot;Hello, World!&quot;);
  return 0;
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[C语言教程 - 目录]]></title>
        <id>https://blog.lzw-723.xyz/post/c-yu-yan-jiao-cheng-mu-lu/</id>
        <link href="https://blog.lzw-723.xyz/post/c-yu-yan-jiao-cheng-mu-lu/">
        </link>
        <updated>2021-08-06T00:55:20.000Z</updated>
        <summary type="html"><![CDATA[<blockquote>
<p>本教程是笔者对<a href="https://github.com/ronreiter/interactive-tutorials/blob/master/tutorials/learn-c.org/">learn-c.org</a>的翻译，详见<a href="https://github.com/ronreiter/interactive-tutorials/pull/611">Added learn-c.org Chinese translation</a>，转载后交互式内容缺失，可以前往<a href="https://www.learn-c.org/zh/">learn-c.org 中文版</a>查看。</p>
</blockquote>
]]></summary>
        <content type="html"><![CDATA[<blockquote>
<p>本教程是笔者对<a href="https://github.com/ronreiter/interactive-tutorials/blob/master/tutorials/learn-c.org/">learn-c.org</a>的翻译，详见<a href="https://github.com/ronreiter/interactive-tutorials/pull/611">Added learn-c.org Chinese translation</a>，转载后交互式内容缺失，可以前往<a href="https://www.learn-c.org/zh/">learn-c.org 中文版</a>查看。</p>
</blockquote>
<!-- more -->
<h1 id="欢迎">欢迎</h1>
<p>欢迎来到learn-c.org的免费交互式C语言教程。</p>
<p>这个网站都是为每个希望学习C语言的人准备的，无论你是否是一个有经验的程序员。</p>
<p>不需要下载任何东西——只需点击你想开始的章节，然后按照指示操作。祝您好运!</p>
<p>learn-c.org仍在建设中——如果你想贡献教程，请点击下方的<code>贡献教程</code>。</p>
<h3 id="基础学习">基础学习</h3>
<ul>
<li><a href="../c-yu-yan-jiao-cheng-ni-hao-shi-jie">你好，世界!</a></li>
<li><a href="../c-yu-yan-jiao-cheng-bian-liang-he-lei-xing">变量和类型</a></li>
<li>[[数组]]</li>
<li>[[Multidimensional Arrays]]</li>
<li>[[Conditions]]</li>
<li>[[Strings]]</li>
<li>[[For loops]]</li>
<li>[[While loops]]</li>
<li>[[Functions]]</li>
<li>[[Static]]</li>
</ul>
<h3 id="进阶内容">进阶内容</h3>
<ul>
<li>[[Pointers]]</li>
<li>[[Structures]]</li>
<li>[[Function arguments by reference]]</li>
<li>[[Dynamic allocation]]</li>
<li>[[Arrays and Pointers]]</li>
<li>[[Recursion]]</li>
<li>[[Linked lists]]</li>
<li>[[Binary trees]]</li>
<li>[[Unions]]</li>
<li>[[Pointer Arithmetics]]</li>
<li>[[Function Pointers]]</li>
<li>[[Bitmasks]]</li>
</ul>
<h3 id="贡献教程">贡献教程</h3>
<p>在此阅读更多信息：[[Contributing Tutorials]]</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Project Vogen技术栈分析]]></title>
        <id>https://blog.lzw-723.xyz/post/project-vogen-ji-zhu-zhan-fen-xi/</id>
        <link href="https://blog.lzw-723.xyz/post/project-vogen-ji-zhu-zhan-fen-xi/">
        </link>
        <updated>2021-07-30T04:11:28.000Z</updated>
        <summary type="html"><![CDATA[<p>AI歌声合成引擎</p>
]]></summary>
        <content type="html"><![CDATA[<p>AI歌声合成引擎</p>
<!-- more -->
<h2 id="project-vogen">Project Vogen</h2>
<h3 id="简介">简介</h3>
<p><code>Project Vogen</code> 未来虚拟唱鸽人<br>
该项目为 <a href="https://space.bilibili.com/169955">Doaz大佬</a> 在读博期间以个人名义发起的歌声合成项目。</p>
<h3 id="相关">相关</h3>
<ul>
<li>技术：Doaz</li>
<li>美术：菠菠冥</li>
<li>清华大学智能技术与系统国家重点实验室</li>
<li>清华大学未来动漫·游戏技术兴趣团队</li>
</ul>
<blockquote>
<p><img src="https://i.niupic.com/images/2021/07/30/9pwR.jpg" alt="fw" loading="lazy"><br>
<s>留下了不争气的泪水.jpg</s></p>
</blockquote>
<h2 id="注意">注意</h2>
<blockquote>
<p><code>Project Vogen</code>项目涉及到以下内容（不完全统计）：</p>
<ul>
<li>编程语言：<code>F#</code> <code>C++</code> <code>C</code> <code>Objective-C</code>  <code>C#</code></li>
<li><code>.NET Framework WPF（Windows Presentation Foundation）</code>  GUI<br>
<code>DirectML</code> 机器学习<br>
<code>NAudio</code> 音频处理类库<br>
<code>WORLD</code> 语音分析/合成系统<br>
<img src="https://i.niupic.com/images/2021/07/30/9pwW.jpeg" alt="" loading="lazy"><br>
<strong>本文并不严谨，内容多为查找资料后猜测所得。</strong><br>
<img src="https://i.niupic.com/images/2021/07/30/9pwZ.jpeg" alt="" loading="lazy"></li>
</ul>
</blockquote>
<h2 id="vogenclient">Vogen.Client</h2>
<h2 id="资料来源">资料来源</h2>
<p>[1] <a href="https://gitee.com/aqtq314/Vogen.Client">Vogen.Client-Gitee (客户端))</a><br>
[2] <a href="https://github.com/aqtq314/Vogen.Client">Vogen.Client-Github (客户端)</a><br>
[3] <a href="https://jq.qq.com/?_wv=1027&amp;k=QPgAUFS6">Vogen鸽声合成交流 (QQ群)</a><br>
[4] <a href="https://github.com/mmorise/World">WORLD</a></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Java日志学习]]></title>
        <id>https://blog.lzw-723.xyz/post/java-ri-zhi-xue-xi/</id>
        <link href="https://blog.lzw-723.xyz/post/java-ri-zhi-xue-xi/">
        </link>
        <updated>2021-07-01T04:32:24.000Z</updated>
        <summary type="html"><![CDATA[<p>不要再滥用<code>System.out.println()</code>了</p>
]]></summary>
        <content type="html"><![CDATA[<p>不要再滥用<code>System.out.println()</code>了</p>
<!-- more -->
<hr>
<h2 id="日志概念">日志概念</h2>
<h3 id="日志是什么">日志是什么</h3>
<blockquote>
<p>生活中的日志是记录你生活的点点滴滴，让它把你内心的世界表露出来，更好的诠释自己的内心世界，而电脑里的日志可以是有价值的信息宝库，也可以是毫无价值的数据泥潭。</p>
</blockquote>
<p>网络设备、系统及服务程序等，在运作时都会产生一个叫<code>log</code>的事件记录；每一行日志都记载着日期、时间、使用者及动作等相关操作的描述。</p>
<h3 id="日志有什么优点">日志有什么优点</h3>
<p>输出日志，而不是用<code>System.out.println()</code>，有以下几个好处：</p>
<ol>
<li>可以设置输出样式，避免自己每次都写<code>&quot;ERROR: &quot; + var</code>；</li>
<li>可以设置输出级别，禁止某些级别输出。例如，只输出错误日志；</li>
<li>可以被重定向到文件，这样可以在程序运行结束后查看日志；</li>
<li>可以按包名控制日志级别，只输出某些包打的日志；</li>
<li>……</li>
</ol>
<p>总之就是十分友好。</p>
<hr>
<h2 id="java中的日志">Java中的日志</h2>
<h3 id="常见的日志工具">常见的日志工具</h3>
<ul>
<li>[日志实现]<code>Java</code>标准库内置的日志包<code>java.util.logging</code></li>
<li>[<strong>日志接口</strong>][不活跃]<code>Apache</code>软件基金会的<a href="https://commons.apache.org/proper/commons-logging/"><code>Commons Logging</code></a></li>
<li>[<strong>日志接口</strong>][<strong>活跃</strong>]<code>QOS.ch</code>的日志抽象<a href="http://www.slf4j.org/"><code>SLF4J</code></a></li>
<li>[日志实现][不活跃]<code>Apache</code>软件基金会的<a href="https://logging.apache.org/log4j/"><code>log4j</code></a></li>
<li>[日志实现][<strong>活跃</strong>]<code>QOS.ch</code>的<a href="https://logback.qos.ch/"><code>Logback</code></a></li>
</ul>
<h3 id="我的选择">我的选择</h3>
<p>截止当前(<em>2021年7月1日</em>)以上只有<code>SLF4J</code>和<code>Logback</code>近期(<strong>一个月内</strong>)还有<code>commit</code><br>
所以笔者做以下选择</p>
<ul>
<li><code>SLF4J</code> + <code>Logback</code></li>
</ul>
<h3 id="准备工作">准备工作</h3>
<h4 id="新建示例工程">新建示例工程</h4>
<p>笔者选择使用更为简单的<code>Maven</code>工程<br>
目录结构如下（已删去无关文件）</p>
<pre><code class="language-shell">│   pom.xml
│
├───src
    └───main
        └───java
            └───com
                └───example
                        App.java
</code></pre>
<p>唯一源代码文件<code>App.java</code></p>
<pre><code class="language-java">package com.example;

/**
 * Hello world!
 *
 */
public class App
{
    public static void main( String[] args )
    {
        System.out.println( &quot;Hello World!&quot; );
    }
}
</code></pre>
<h3 id="配置工程依赖">配置工程依赖</h3>
<pre><code class="language-xml">  &lt;dependencies&gt;
    &lt;!-- slf4j-api --&gt;
    &lt;dependency&gt;
      &lt;groupId&gt;org.slf4j&lt;/groupId&gt;
      &lt;artifactId&gt;slf4j-api&lt;/artifactId&gt;
      &lt;version&gt;1.7.31&lt;/version&gt;
    &lt;/dependency&gt;
    &lt;!-- logback --&gt;
    &lt;dependency&gt;
      &lt;groupId&gt;ch.qos.logback&lt;/groupId&gt;
      &lt;artifactId&gt;logback-core&lt;/artifactId&gt;
      &lt;version&gt;1.2.3&lt;/version&gt;
    &lt;/dependency&gt;
    &lt;!-- logback-classic（已含有对slf4j的集成包） --&gt;
    &lt;dependency&gt;
      &lt;groupId&gt;ch.qos.logback&lt;/groupId&gt;
      &lt;artifactId&gt;logback-classic&lt;/artifactId&gt;
      &lt;version&gt;1.2.3&lt;/version&gt;
    &lt;/dependency&gt;
  &lt;/dependencies&gt;
</code></pre>
<h2 id="上手">上手</h2>
<h3 id="最基本的用法">最基本的用法</h3>
<pre><code class="language-java">    public static void main(String[] args) {
        System.out.println(&quot;Hello World!&quot;);
        helloSLF4J();
    }

    public static void helloSLF4J() {
        Logger logger = LoggerFactory.getLogger(App.class);
        logger.info(&quot;Hello SLF4J!&quot;);
    }
</code></pre>
<p>控制台输出</p>
<pre><code class="language-shell">Hello World!
16:38:54.863 [main] INFO com.example.App - Hello SLF4J!
</code></pre>
<p>看到没，<code>时间 [线程] 日志等级 所在类 - 信息</code>的友善格式完胜直接<code>System.out.println()</code></p>
<h3 id="slf4j日志等级">SLF4J日志等级</h3>
<p>优先级由低到高：</p>
<ol>
<li>trace - 一般用来追踪详细的程序运行流</li>
<li>debug - 这类日志往往用在调试场景</li>
<li>info - 用来记录程序运行的一些关键信息</li>
<li>warn - 用来记录一些警告信息</li>
<li>error - 用来记录运行时的错误信息</li>
</ol>
<p>代码实例</p>
<pre><code class="language-java">        Logger logger = LoggerFactory.getLogger(App.class);
        logger.trace(&quot;Hello trace!&quot;);
        logger.debug(&quot;Hello debug!&quot;);
        logger.info(&quot;Hello info!&quot;);
        logger.warn(&quot;Hello warn!&quot;);
        logger.error(&quot;Hello error!&quot;);
</code></pre>
<p>控制台输出</p>
<pre><code class="language-shell">16:56:14.662 [main] DEBUG com.example.App - Hello debug!
16:56:14.669 [main] INFO com.example.App - Hello info!
16:56:14.669 [main] WARN com.example.App - Hello warn!
16:56:14.669 [main] ERROR com.example.App - Hello error!
</code></pre>
<p>可以看到除了trace其余等级的日志都打印了出来，为什么trace那么可怜？答案下节揭晓。</p>
<h3 id="配置文件logback">配置文件(Logback)</h3>
<p>SLF4J不过是日志接口而已，要想对日志进行配置，还需要在resources目录下新建一个配置文件。</p>
<pre><code class="language-shell">│   pom.xml
│
├───src
    └───main
        ├───java
        │   └───com
        │       └───example
        │               App.java
        │
        └───resources
                logback.xml
</code></pre>
<p>配置文件格式可以是<code>groovy</code>或<code>xml</code>，笔者不熟悉<code>groovy</code>，所以选择<code>xml</code>格式。</p>
<h4 id="groovy">Groovy</h4>
<p><code>Groovy</code>是一种基于<code>JVM</code> 的敏捷开发语言，它结合了<code>Python</code>、<code>Ruby</code> 和 <code>Smalltalk</code> 的许多强大的特性。既可以作为脚本语言直接解释执行，也可以编译成<code>Java</code>字节码执行，十分强大。<br>
这里不做过多介绍。</p>
<h4 id="xml">XML</h4>
<blockquote>
<p>XML 指可扩展标记语言（e<strong>X</strong>tensible <strong>M</strong>arkup <strong>L</strong>anguage）。<br>
XML 被设计用来传输和存储数据。</p>
</blockquote>
<p><em>logback.xml</em>内容如下</p>
<pre><code class="language-xml">&lt;configuration&gt;

    &lt;appender name=&quot;STDOUT&quot; class=&quot;ch.qos.logback.core.ConsoleAppender&quot;&gt;
        &lt;encoder&gt;
            &lt;pattern&gt;xml %d{HH:mm:ss.SSS} [%thread] %-5level %logger{36} - %msg%n&lt;/pattern&gt;
        &lt;/encoder&gt;
    &lt;/appender&gt;

    &lt;root level=&quot;trace&quot;&gt;
        &lt;appender-ref ref=&quot;STDOUT&quot; /&gt;
    &lt;/root&gt;
&lt;/configuration&gt;
</code></pre>
<h5 id="名词解释">名词解释</h5>
<table>
<thead>
<tr>
<th>名词</th>
<th>意义</th>
</tr>
</thead>
<tbody>
<tr>
<td>configuration</td>
<td>配置</td>
</tr>
<tr>
<td>appender</td>
<td>输出源</td>
</tr>
<tr>
<td>encoder</td>
<td>编码器</td>
</tr>
<tr>
<td>pattern</td>
<td>模式</td>
</tr>
<tr>
<td>layout</td>
<td>布局</td>
</tr>
<tr>
<td>root</td>
<td>根</td>
</tr>
</tbody>
</table>
<p>笔者从<code>logback</code>官方手册中复制了一个最简单的配置，但又有所修改。<br>
文件定义了一个名为<code>STDOUT</code>的<code>appender</code>，又它的<code>class</code>属性可以看出，它是一个向控制台输出的<code>appender</code>。<br>
这个<code>appender</code>的<code>encoder</code>的<code>pattern</code>是<code>xml %d{HH:mm:ss.SSS} [%thread] %-5level %logger{36} - %msg%n</code>。</p>
<h5 id="conversion-word">Conversion Word</h5>
<blockquote>
<p>像%d{HH:mm:ss.SSS}中的{HH:mm:ss.SSS}是代表时间的格式，{}中的内容是转义词的一些属性。<br>
更详细的解释可以看<a href="https://logback.qos.ch/manual/layouts.html#conversionWord">这里</a></p>
</blockquote>
<p>转义词(<em>Conversion Word</em>)表[部分]</p>
<table>
<thead>
<tr>
<th>名词</th>
<th>意义</th>
</tr>
</thead>
<tbody>
<tr>
<td>%d</td>
<td>当前时间</td>
</tr>
<tr>
<td>%thread</td>
<td>当前线程</td>
</tr>
<tr>
<td>%level</td>
<td>当前消息等级</td>
</tr>
<tr>
<td>%logger</td>
<td>当前logger</td>
</tr>
<tr>
<td>%msg</td>
<td>消息内容</td>
</tr>
<tr>
<td>%n</td>
<td>换行</td>
</tr>
</tbody>
</table>
<p>搞懂了<code>%</code>和<code>{}</code>的意义，但这个<code>%-5level</code>中间夹的<code>-5</code>又是怎么回事？</p>
<h5 id="format-modifiers">Format modifiers</h5>
<blockquote>
<p>用格式修饰符可以美观地对齐内容。<br>
点击<a href="https://logback.qos.ch/manual/layouts.html#formatModifiers">这里</a>看更多用法与详解。</p>
</blockquote>
<p>格式修饰符(<em>Format modifiers</em>)表[部分]</p>
<table>
<thead>
<tr>
<th>格式修饰符</th>
<th>左对齐</th>
<th>最小宽度[字符]</th>
<th>最大宽度[字符]</th>
</tr>
</thead>
<tbody>
<tr>
<td>%20logger</td>
<td>否</td>
<td>20</td>
<td>无</td>
</tr>
<tr>
<td>%-20loggerr</td>
<td>是</td>
<td>20</td>
<td>无</td>
</tr>
<tr>
<td>%.30logger</td>
<td>-</td>
<td>无</td>
<td>30</td>
</tr>
</tbody>
</table>
<p>所以，<code>%-5level</code>就是将等级以最小5个字符左对齐。</p>
<p><code>root</code>是配置的根，它的输出等级是<code>trace</code>，<code>root</code>中引用了名为<code>STDOUT</code>的<code>appender</code>。<br>
让我们再运行一次工程。</p>
<pre><code class="language-shell">xml 17:30:34.232 [main] TRACE com.example.App - Hello trace!
xml 17:30:34.234 [main] DEBUG com.example.App - Hello debug!
xml 17:30:34.235 [main] INFO  com.example.App - Hello info!
xml 17:30:34.235 [main] WARN  com.example.App - Hello warn!
xml 17:30:34.235 [main] ERROR com.example.App - Hello error!
</code></pre>
<p>look!!!<br>
每行日志开头都由我们写进<code>pattern</code>的<strong>xml</strong>开头，我们的<code>xml</code>配置文件生效了。而且这一次，<code>trace</code>级别的日志打印出来了！再也不是没人爱了！</p>
<h4 id="输出日志到文件">输出日志到文件</h4>
<p>新增<code>appender</code></p>
<pre><code class="language-xml">&lt;appender name=&quot;FILE&quot; class=&quot;ch.qos.logback.core.FileAppender&quot;&gt;
        &lt;file&gt;myApp.log&lt;/file&gt;
        &lt;encoder&gt;
            &lt;pattern&gt;file %date %level [%thread] %logger{36} [%file:%line] %msg%n&lt;/pattern&gt;
        &lt;/encoder&gt;
    &lt;/appender&gt;
</code></pre>
<p>别忘了在<code>root</code>中引用</p>
<pre><code class="language-xml">&lt;appender-ref ref=&quot;FILE&quot; /&gt;
</code></pre>
<p>运行代码<br>
发现项目目录下出现了myApp.log文件<br>
查看内容</p>
<pre><code class="language-shell">file 2021-07-09 12:53:33,940 TRACE [main] com.example.App [App.java:22] Hello trace!
file 2021-07-09 12:53:33,942 DEBUG [main] com.example.App [App.java:23] Hello debug!
file 2021-07-09 12:53:33,943 INFO [main] com.example.App [App.java:24] Hello info!
file 2021-07-09 12:53:33,943 WARN [main] com.example.App [App.java:25] Hello warn!
file 2021-07-09 12:53:33,948 ERROR [main] com.example.App [App.java:26] Hello error!
</code></pre>
<p>正如我们定义<code>appender</code>一样。</p>
<h2 id="参考资料">参考资料</h2>
<p>[1] <a href="https://baike.baidu.com/item/%E6%97%A5%E5%BF%97/2769135?fr=aladdin">百度百科 日志</a><br>
[2] <a href="https://www.liaoxuefeng.com/wiki/1252599548343744">廖雪峰的官方网站 Java教程</a><br>
[3] <a href="http://www.slf4j.org/">SLF4J官网</a><br>
[4] <a href="https://logback.qos.ch/">Logback官网</a><br>
[5] <a href="https://juejin.cn/post/6844903949598736391#heading-5">Java日志框架：SLF4J详解</a><br>
[6] <a href="https://www.jianshu.com/p/ec3bd614dcb0">SLF4J日志级别以及使用场景</a><br>
[7] <a href="https://www.runoob.com/xml/xml-tutorial.html">XML 教程</a></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Vue初体验]]></title>
        <id>https://blog.lzw-723.xyz/post/vue-chu-ti-yan/</id>
        <link href="https://blog.lzw-723.xyz/post/vue-chu-ti-yan/">
        </link>
        <updated>2021-02-12T09:29:59.000Z</updated>
        <summary type="html"><![CDATA[<p><code>Vue</code> (读音 <em>/vjuː/</em>，类似于 <strong>view</strong>) 是一套用于构建用户界面的渐进式框架。</p>
]]></summary>
        <content type="html"><![CDATA[<p><code>Vue</code> (读音 <em>/vjuː/</em>，类似于 <strong>view</strong>) 是一套用于构建用户界面的渐进式框架。</p>
<!-- more -->
<p>与其它大型框架不同的是，<code>Vue</code> 被设计为可以自底向上逐层应用。<code>Vue</code> 的核心库只关注视图层，不仅易于上手，还便于与第三方库或既有项目整合。另一方面，当与现代化的工具链以及各种支持类库结合使用时，<code>Vue</code> 也完全能够为复杂的单页应用提供驱动。</p>
<h2 id="准备工作">准备工作</h2>
<h3 id="1配置nodejs">1.配置<code>nodejs</code></h3>
<p>到<a href="https://nodejs.org/en/download/">Nodejs官网</a>或<a href="http://nodejs.cn/download/">Nodejs中文网</a>直接下载对应操作系统的安装包，一路Next完成。</p>
<blockquote>
<p>建议选择<code>LTS</code>(长期支持)版本</p>
</blockquote>
<h3 id="2配置pnpm">2.配置pnpm</h3>
<blockquote>
<p>这一步可选，但如果不选择，后文<code>pnpm</code>需替换为<code>npm</code></p>
</blockquote>
<p>pnpm像npm一样也是一个包管理器，用法几乎一样。<br>
它的优点是<strong>快、节省磁盘占用</strong><br>
<img src="https://s3.ax1x.com/2021/02/12/yDb8zj.png" alt="pnpm与npm与yarn对比" title="pnpm与npm与yarn对比" loading="lazy"><br>
在window下它会在项目所在驱动器中一个隐藏目录下保存所有包，这个驱动器中的所有工程都是引用这里的文件，所以，只有一份文件在磁盘中，大大减少了空间占用。<br>
<img src="https://s3.ax1x.com/2021/02/12/yDbvtS.png" alt="我的例子" loading="lazy"></p>
<h4 id="下载安装">下载安装</h4>
<blockquote>
<p>详细情况见<a href="https://pnpm.js.org/en/installation">pnpm官网安装介绍</a></p>
</blockquote>
<p>执行下面命令：</p>
<pre><code class="language-shell">npm install -g pnpm
</code></pre>
<h4 id="注意">注意</h4>
<p>虽然<code>pnpm</code>可以配置储存路径，但会使其他盘的包引用失效。</p>
<h3 id="安装vuecli">安装<code>@vue/cli</code></h3>
<p>直接</p>
<pre><code class="language-shell">npm install -g @vue/cli
</code></pre>
<h2 id="新建项目">新建项目</h2>
<p>在想要创建的工程的父目录下执行</p>
<pre><code class="language-shell">vue create hello-world
</code></pre>
<p>选择<code>vue3</code><br>
<img src="https://s3.ax1x.com/2021/02/12/yDLoqI.png" alt="vue3" loading="lazy"></p>
<p>出现下图则新建成功<br>
<img src="https://s3.ax1x.com/2021/02/12/yDLHdP.png" alt="成功" loading="lazy"></p>
<h2 id="运行">运行</h2>
<p>根据提示在浏览器打开地址<br>
<img src="https://s3.ax1x.com/2021/02/12/yDL7Zt.png" alt="提示" loading="lazy"><br>
<img src="https://s3.ax1x.com/2021/02/12/yDLbIf.png" alt="浏览器" loading="lazy"><br>
<strong>成功！！！</strong></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Markdown语法总结]]></title>
        <id>https://blog.lzw-723.xyz/post/markdown-yu-fa-zong-jie/</id>
        <link href="https://blog.lzw-723.xyz/post/markdown-yu-fa-zong-jie/">
        </link>
        <updated>2020-02-04T04:24:43.000Z</updated>
        <summary type="html"><![CDATA[<p><strong>Markdown</strong> 是一种轻量级标记语言，它允许人们使用易读易写的纯文本格式编写文档。</p>
]]></summary>
        <content type="html"><![CDATA[<p><strong>Markdown</strong> 是一种轻量级标记语言，它允许人们使用易读易写的纯文本格式编写文档。</p>
<!-- more -->
<h2 id="markdow简介">Markdow简介</h2>
<p><strong>Markdown</strong> 语言在 2004 由约翰·格鲁伯（英语：John Gruber）创建。</p>
<p><strong>Markdown</strong> 编写的文档可以导出 <code>HTML</code> 、<code>Word</code>、图像、<code>PDF</code>、<code>Epub</code> 等多种格式的文档。</p>
<p><strong>Markdown</strong> 编写的文档后缀为 <code>.md</code>, <code>.markdown</code></p>
<h3 id="基本语法">基本语法</h3>
<h4 id="标题">标题</h4>
<pre><code class="language-md"># 一级标题
## 二级标题
### 三级标题
#### 四级标题
##### 五级标题
###### 六级标题
</code></pre>
<h4 id="段落">段落</h4>
<p><strong>Markdown</strong> 段落没有特殊的格式，直接编写文字就好，段落的换行是使用两个以上<code>空格</code>加上回车。<br>
也可以在段落后面使用一个<code>空行</code>来表示重新开始一个段落。</p>
<h4 id="字体">字体</h4>
<pre><code class="language-md">*斜体文本*
_斜体文本_
**粗体文本**
__粗体文本__
***粗斜体文本***
___粗斜体文本___
&lt;u&gt;带下划线文本&lt;/u&gt;
脚注格式类似这样 [^脚注]。
[^脚注]: 2333
</code></pre>
<p><em>斜体文本</em><br>
<em>斜体文本</em><br>
<strong>粗体文本</strong><br>
<strong>粗体文本</strong><br>
<em><strong>粗斜体文本</strong></em><br>
<em><strong>粗斜体文本</strong></em><br>
<u>带下划线文本</u><br>
脚注格式类似这样 <sup class="footnote-ref"><a href="#fn1" id="fnref1">[1]</a></sup>。</p>
<h4 id="分隔线">分隔线</h4>
<pre><code class="language-md">***
* * *
*****
- - -
----------
</code></pre>
<hr>
<hr>
<hr>
<hr>
<hr>
<h4 id="删除线">删除线</h4>
<pre><code class="language-md">百度
~~谷歌~~
</code></pre>
<p>百度<br>
<s>谷歌</s></p>
<h4 id="列表">列表</h4>
<h5 id="无序列表">无序列表</h5>
<pre><code class="language-md">* 第一项
+ 第二项
- 第三项
</code></pre>
<ul>
<li>第一项</li>
</ul>
<ul>
<li>第二项</li>
</ul>
<ul>
<li>第三项</li>
</ul>
<!-- more -->
<h5 id="有序列表">有序列表</h5>
<pre><code class="language-md">1. 第一项
2. 第二项
3. 第三项
</code></pre>
<ol>
<li>第一项</li>
<li>第二项</li>
<li>第三项</li>
</ol>
<h5 id="嵌套列表">嵌套列表</h5>
<p>两个<code>空格</code></p>
<pre><code class="language-md">* 第一项
  * 第一项嵌套的第一个元素
  * 第一项嵌套的第二个元素
</code></pre>
<ul>
<li>第一项
<ul>
<li>第一项嵌套的第一个元素</li>
<li>第一项嵌套的第二个元素</li>
</ul>
</li>
</ul>
<h4 id="任务列表">任务列表</h4>
<pre><code class="language-md">* [x] task list 1
* [x] task list 2
* [ ] task list 3
  * [ ] task list 3-1
  * [ ] task list 3-2
    * [ ] task list 3-2-1
* [ ] task list 4
  * [ ] task list 4-1
  * [ ] task list 4-2
</code></pre>
<ul class="contains-task-list">
<li class="task-list-item"><input class="task-list-item-checkbox" checked="" disabled="" type="checkbox" id="task-item-3791932"><label class="task-list-item-label" for="task-item-3791932"> task list 1</label></li>
<li class="task-list-item"><input class="task-list-item-checkbox" checked="" disabled="" type="checkbox" id="task-item-3472068"><label class="task-list-item-label" for="task-item-3472068"> task list 2</label></li>
<li class="task-list-item"><input class="task-list-item-checkbox" disabled="" type="checkbox" id="task-item-6927232"><label class="task-list-item-label" for="task-item-6927232"> task list 3</label>
<ul class="contains-task-list">
<li class="task-list-item"><input class="task-list-item-checkbox" disabled="" type="checkbox" id="task-item-9403451"><label class="task-list-item-label" for="task-item-9403451"> task list 3-1</label></li>
<li class="task-list-item"><input class="task-list-item-checkbox" disabled="" type="checkbox" id="task-item-9284830"><label class="task-list-item-label" for="task-item-9284830"> task list 3-2</label>
<ul class="contains-task-list">
<li class="task-list-item"><input class="task-list-item-checkbox" disabled="" type="checkbox" id="task-item-9941153"><label class="task-list-item-label" for="task-item-9941153"> task list 3-2-1</label></li>
</ul>
</li>
</ul>
</li>
<li class="task-list-item"><input class="task-list-item-checkbox" disabled="" type="checkbox" id="task-item-9500850"><label class="task-list-item-label" for="task-item-9500850"> task list 4</label>
<ul class="contains-task-list">
<li class="task-list-item"><input class="task-list-item-checkbox" disabled="" type="checkbox" id="task-item-9579576"><label class="task-list-item-label" for="task-item-9579576"> task list 4-1</label></li>
<li class="task-list-item"><input class="task-list-item-checkbox" disabled="" type="checkbox" id="task-item-2151280"><label class="task-list-item-label" for="task-item-2151280"> task list 4-2</label></li>
</ul>
</li>
</ul>
<h4 id="区块">区块</h4>
<pre><code class="language-md">&gt; 区块
&gt; 区块  
&gt; 最外层
&gt;&gt; 第一层嵌套
&gt;&gt;&gt; 第二层嵌套
</code></pre>
<blockquote>
<p>区块<br>
区块<br>
最外层</p>
<blockquote>
<p>第一层嵌套</p>
<blockquote>
<p>第二层嵌套</p>
</blockquote>
</blockquote>
</blockquote>
<h4 id="代码">代码</h4>
<pre><code class="language-md">`code`
```java
System.out.println(&quot;Hello World&quot;);
\```
</code></pre>
<p><code>code</code></p>
<pre><code class="language-java">System.out.println(&quot;Hello World&quot;);
</code></pre>
<h4 id="链接">链接</h4>
<pre><code class="language-md">[Pixiv搜索](https://pixivic.com/)
[我的博客](https://lzw-723.github.io)
</code></pre>
<p><a href="https://pixivic.com/">Pixiv搜索</a><br>
<a href="https://lzw-723.github.io">我的博客</a></p>
<h4 id="图片">图片</h4>
<pre><code class="language-md">![alt 属性文本](图片地址)
![alt 属性文本](图片地址 &quot;可选标题&quot;)

![比企谷八幡](https://s2.ax1x.com/2020/02/22/3MhWfs.jpg)

![雪ノ下雪乃](https://s2.ax1x.com/2020/02/22/3MfbRI.jpg &quot;雪ノ下雪乃&quot;)
</code></pre>
<figure data-type="image" tabindex="1"><img src="%E5%9B%BE%E7%89%87%E5%9C%B0%E5%9D%80" alt="alt 属性文本" loading="lazy"></figure>
<figure data-type="image" tabindex="2"><img src="%E5%9B%BE%E7%89%87%E5%9C%B0%E5%9D%80" alt="alt 属性文本" title="可选标题" loading="lazy"></figure>
<figure data-type="image" tabindex="3"><img src="https://s2.ax1x.com/2020/02/22/3MhWfs.jpg" alt="比企谷八幡" loading="lazy"></figure>
<figure data-type="image" tabindex="4"><img src="https://s2.ax1x.com/2020/02/22/3MfbRI.jpg" alt="雪ノ下雪乃" title="雪ノ下雪乃" loading="lazy"></figure>
<h4 id="表格">表格</h4>
<p><strong>Markdown</strong> 制作表格使用 | 来分隔不同的单元格，使用 - 来分隔表头和其他行。</p>
<pre><code class="language-md">|  表头   | 表头  |
|  ----  | ----  |
| 单元格  | 单元格 |
| 单元格  | 单元格 |
</code></pre>
<table>
<thead>
<tr>
<th>表头</th>
<th>表头</th>
</tr>
</thead>
<tbody>
<tr>
<td>单元格</td>
<td>单元格</td>
</tr>
<tr>
<td>单元格</td>
<td>单元格</td>
</tr>
</tbody>
</table>
<h3 id="高级技巧">高级技巧</h3>
<h4 id="html">HTML</h4>
<p>不在 <strong>Markdown</strong> 涵盖范围之内的标签，都可以直接在文档里面用 <strong>HTML</strong> 撰写。</p>
<p>目前支持的 HTML 元素有：<code>&lt;kbd&gt; &lt;b&gt; &lt;i&gt; &lt;em&gt; &lt;sup&gt; &lt;sub&gt; &lt;br&gt;</code>等</p>
<pre><code class="language-md">使用 &lt;kbd&gt;Win&lt;/kbd&gt;+&lt;kbd&gt;L&lt;/kbd&gt; 锁屏
</code></pre>
<p>使用 <kbd>Win</kbd>+<kbd>L</kbd> 锁屏</p>
<h4 id="转义">转义</h4>
<p><strong>Markdown</strong> 使用了很多特殊符号来表示特定的意义，如果需要显示特定的符号则需要使用反斜杠 <code>\</code> 转义特殊字符</p>
<pre><code class="language-md">**文本加粗** 
\*\* 正常显示星号 \*\*
</code></pre>
<p><strong>文本加粗</strong><br>
** 正常显示星号 **</p>
<h4 id="公式">公式</h4>
<p>当你需要在编辑器中插入数学公式时，可以使用两个美元符 <code>$$</code> 包裹 <code>TeX</code> 或 <code>LaTeX</code> 格式的数学公式来实现。提交后，问答和文章页会根据需要加载 <code>Mathjax</code> 对数学公式进行渲染。</p>
<pre><code class="language-md">$$ x &gt; y $$

$$ E=mc^2 $$

$$ \sin(\alpha)^{\theta}=\sum_{i=0}^{n}(x^i + \cos(f)) $$
</code></pre>
<p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>x</mi><mo>&gt;</mo><mi>y</mi></mrow><annotation encoding="application/x-tex">x &gt; y 
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5782em;vertical-align:-0.0391em;"></span><span class="mord mathdefault">x</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&gt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span></span></span></span></span></p>
<p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>E</mi><mo>=</mo><mi>m</mi><msup><mi>c</mi><mn>2</mn></msup></mrow><annotation encoding="application/x-tex">E=mc^2 
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.05764em;">E</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8641079999999999em;vertical-align:0em;"></span><span class="mord mathdefault">m</span><span class="mord"><span class="mord mathdefault">c</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8641079999999999em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span></span></span></span></span></p>
<p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>sin</mi><mo>⁡</mo><mo>(</mo><mi>α</mi><msup><mo>)</mo><mi>θ</mi></msup><mo>=</mo><munderover><mo>∑</mo><mrow><mi>i</mi><mo>=</mo><mn>0</mn></mrow><mi>n</mi></munderover><mo>(</mo><msup><mi>x</mi><mi>i</mi></msup><mo>+</mo><mi>cos</mi><mo>⁡</mo><mo>(</mo><mi>f</mi><mo>)</mo><mo>)</mo></mrow><annotation encoding="application/x-tex">\sin(\alpha)^{\theta}=\sum_{i=0}^{n}(x^i + \cos(f)) 
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.149108em;vertical-align:-0.25em;"></span><span class="mop">sin</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.0037em;">α</span><span class="mclose"><span class="mclose">)</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8991079999999999em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.02778em;">θ</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:2.929066em;vertical-align:-1.277669em;"></span><span class="mop op-limits"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.6513970000000002em;"><span style="top:-1.872331em;margin-left:0em;"><span class="pstrut" style="height:3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">i</span><span class="mrel mtight">=</span><span class="mord mtight">0</span></span></span></span><span style="top:-3.050005em;"><span class="pstrut" style="height:3.05em;"></span><span><span class="mop op-symbol large-op">∑</span></span></span><span style="top:-4.3000050000000005em;margin-left:0em;"><span class="pstrut" style="height:3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">n</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.277669em;"><span></span></span></span></span></span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8746639999999999em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mop">cos</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mclose">)</span><span class="mclose">)</span></span></span></span></span></p>
<h3 id="资料引用">资料引用</h3>
<p><a href="https://www.runoob.com/markdown">菜鸟教程</a><br>
<a href="https://www.mdeditor.com/">MdEditor</a></p>
<hr class="footnotes-sep">
<section class="footnotes">
<ol class="footnotes-list">
<li id="fn1" class="footnote-item"><p>2333 <a href="#fnref1" class="footnote-backref">↩︎</a></p>
</li>
</ol>
</section>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Java中序列化与反序列化笔记]]></title>
        <id>https://blog.lzw-723.xyz/post/java-zhong-xu-lie-hua-yu-fan-xu-lie-hua-bi-ji/</id>
        <link href="https://blog.lzw-723.xyz/post/java-zhong-xu-lie-hua-yu-fan-xu-lie-hua-bi-ji/">
        </link>
        <updated>2020-01-11T04:33:32.000Z</updated>
        <summary type="html"><![CDATA[<p><code>Java</code> 提供了一种对象序列化的机制，该机制中，一个对象可以被表示为一个字节序列，该字节序列包括该对象的数据、有关对象的类型的信息和存储在对象中数据的类型。</p>
]]></summary>
        <content type="html"><![CDATA[<p><code>Java</code> 提供了一种对象序列化的机制，该机制中，一个对象可以被表示为一个字节序列，该字节序列包括该对象的数据、有关对象的类型的信息和存储在对象中数据的类型。</p>
<!-- more -->
<h2 id="概念">概念</h2>
<p>将序列化对象写入文件之后，可以从文件中读取出来，并且对它进行反序列化，也就是说，对象的类型信息、对象的数据，还有对象中的数据类型可以用来在内存中新建对象。</p>
<p>整个过程都是 <code>Java</code> 虚拟机（<code>JVM</code>）独立的，也就是说，在一个平台上序列化的对象可以在另一个完全不同的平台上反序列化该对象。</p>
<h2 id="实现">实现</h2>
<h3 id="方法">方法</h3>
<p>类 <code>ObjectInputStream</code> 和 <code>ObjectOutputStream</code> 是高层次的数据流，它们包含反序列化和序列化对象的方法。</p>
<pre><code class="language-java">public final void writeObject(Object x) throws IOException
</code></pre>
<p><code>writeObject</code>方法序列化一个对象，并将它发送到输出流。</p>
<p>相似的 <code>ObjectInputStream</code> 类包含如下反序列化一个对象的方法：</p>
<pre><code class="language-java">public final Object readObject() throws IOException, ClassNotFoundException
</code></pre>
<p>readObject方法从流中取出下一个对象，并将对象反序列化。它的返回值为Object，因此，你需要将它转换成合适的数据类型。</p>
<blockquote>
<p>请注意，一个类的对象要想序列化成功，必须满足两个条件：</p>
<blockquote>
<ul>
<li>该类必须实现 <code>java.io.Serializable</code> 接口。</li>
<li>该类的所有属性必须是可序列化的。如果有一个属性不是可序列化的，则该属性必须注明是短暂的。</li>
</ul>
</blockquote>
</blockquote>
<p><code>如果你想知道一个 Java 标准类是否是可序列化的，请查看该类的文档。检验一个类的实例是否能序列化十分简单， 只需要查看该类有没有实现*java.io.Serializable*接口。</code></p>
<p>当序列化一个对象到文件时， 按照 <code>Java</code> 的标准约定是给文件一个 <code>.ser</code> 扩展名。<br>
对于一个实体类，不想将所有的属性都进行序列化，有专门的关键字 <em>transient</em>：</p>
<pre><code class="language-java">private transient String name;
</code></pre>
<p>当对该类序列化时，会自动忽略被 <code>transient</code> 修饰的属性。</p>
<h3 id="代码">代码</h3>
<pre><code class="language-java">/**
 * 序列化测试
 *
 */
public class App {
    /**
     * Person
     */
    public static class Person implements Serializable {

        private String name;
        private int age;
        private transient String info = &quot;nothing&quot;;

        public Person(String name, int age) {
            this.name = name;
            this.age = age;
        }

        public Person setInfo(String info) {
            this.info = info;
            return this;
        }
        public void show(){
            System.out.println(name + '-' + age + '-' + info);
        }
    }

    public static void main(String[] args) throws IOException, ClassNotFoundException {
        writePerson();
        readPerson();
    }

    // 从文件中读取Person对象
    public static void readPerson() throws IOException, ClassNotFoundException {
        // 创建反序列化流
        ObjectInputStream ois = new ObjectInputStream(new FileInputStream(&quot;\\dls.ser&quot;));
        // 从文件中读取对象
        Object obj = ois.readObject();
        ((Person) obj).show();
        // 释放资源
        ois.close();
    }

    // 向文件中写Person对象
    public static void writePerson() throws IOException {
        // 创建序列化流
        ObjectOutputStream oos = new ObjectOutputStream(new FileOutputStream(&quot;\\dls.ser&quot;));
        // 向文件中写Person对象
        oos.writeObject(new Person(&quot;大老师&quot;, 17).setInfo(&quot;没有期望就没有失望，没有羁绊就不会受伤。&quot;));
        // 关流
        oos.close();
    }
}

</code></pre>
<h3 id="输出">输出</h3>
<p><code>大老师-17-null</code></p>
<h2 id="参考资料">参考资料</h2>
<blockquote>
<p><a href="https://www.runoob.com/java/java-serialization.html">Java 序列化 | 菜鸟教程</a></p>
</blockquote>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Java中单例模式笔记]]></title>
        <id>https://blog.lzw-723.xyz/post/java-zhong-dan-li-mo-shi-bi-ji/</id>
        <link href="https://blog.lzw-723.xyz/post/java-zhong-dan-li-mo-shi-bi-ji/">
        </link>
        <updated>2019-01-05T04:06:25.000Z</updated>
        <summary type="html"><![CDATA[<p>单例模式（<code>Singleton Pattern</code>）是 <code>Java</code> 中最简单的设计模式之一。这种类型的设计模式属于创建型模式，它提供了一种创建对象的最佳方式。</p>
]]></summary>
        <content type="html"><![CDATA[<p>单例模式（<code>Singleton Pattern</code>）是 <code>Java</code> 中最简单的设计模式之一。这种类型的设计模式属于创建型模式，它提供了一种创建对象的最佳方式。</p>
<!-- more -->
<p>这种模式涉及到一个单一的类，该类负责创建自己的对象，同时确保只有单个对象被创建。这个类提供了一种访问其唯一的对象的方式，可以直接访问，不需要实例化该类的对象。</p>
<p>注意：</p>
<p>1.单例类只能有一个实例。<br>
2.单例类必须自己创建自己的唯一实例。<br>
3.单例类必须给所有其他对象提供这一实例。<br>
介绍<br>
意图：保证一个类仅有一个实例，并提供一个访问它的全局访问点。</p>
<p>主要解决：一个全局使用的类频繁地创建与销毁。</p>
<p>何时使用：当您想控制实例数目，节省系统资源的时候。</p>
<p>如何解决：判断系统是否已经有这个单例，如果有则返回，如果没有则创建。</p>
<p>关键代码：构造函数是私有的。</p>
<p>应用实例：<br>
1.一个党只能有一个书记。<br>
2.Windows 是多进程多线程的，在操作一个文件的时候，就不可避免地出现多个进程或线程同时操作一个文件的现象，所以所有文件的处理必须通过唯一的实例来进行。<br>
3.一些设备管理器常常设计为单例模式，比如一个电脑有两台打印机，在输出的时候就要处理不能两台打印机打印同一个文件。</p>
<p>优点：<br>
1.在内存里只有一个实例，减少了内存的开销，尤其是频繁的创建和销毁实例（比如管理学院首页页面缓存）。<br>
2.避免对资源的多重占用（比如写文件操作）。</p>
<p>缺点：<br>
没有接口，不能继承，与单一职责原则冲突，一个类应该只关心内部逻辑，而不关心外面怎么样来实例化。</p>
<p>使用场景：<br>
1.要求生产唯一序列号。<br>
2.WEB 中的计数器，不用每次刷新都在数据库里加一次，用单例先缓存起来。 3、创建的一个对象需要消耗的资源过多，比如 I/O 与数据库的连接等。</p>
<p>注意事项：<br>
<code>getInstance()</code> 方法中需要使用同步锁 <code>synchronized (Singleton.class)</code> 防止多线程同时进入造成 <code>instance</code> 被多次实例化。</p>
<p>分为以下两种</p>
<h4 id="懒汉模式">懒汉模式</h4>
<h6 id="懒汉式线程不安全">懒汉式，线程不安全</h6>
<p>是否 Lazy 初始化：是</p>
<p>是否多线程安全：否</p>
<p>实现难度：易</p>
<p>描述：这种方式是最基本的实现方式，这种实现最大的问题就是不支持多线程。因为没有加锁 <code>synchronized</code>，所以严格意义上它并不算单例模式。<br>
这种方式 lazy loading 很明显，不要求线程安全，在多线程不能正常工作。</p>
<p>实例</p>
<pre><code class="language-java">public class Singleton {  
    private static Singleton instance;  
    private Singleton (){}  
  
    public static Singleton getInstance() {  
    if (instance == null) {  
        instance = new Singleton();  
    }  
    return instance;  
    }  
}
</code></pre>
<p>接下来介绍的几种实现方式都支持多线程，但是在性能上有所差异。</p>
<h5 id="2-懒汉式线程安全">2、懒汉式，线程安全</h5>
<p>是否 Lazy 初始化：是</p>
<p>是否多线程安全：是</p>
<p>实现难度：易</p>
<p>描述：这种方式具备很好的 lazy loading，能够在多线程中很好的工作，但是，效率很低，99% 情况下不需要同步。<br>
优点：第一次调用才初始化，避免内存浪费。<br>
缺点：必须加锁 <code>synchronized</code> 才能保证单例，但加锁会影响效率。<br>
<code>getInstance()</code> 的性能对应用程序不是很关键（该方法使用不太频繁）。</p>
<p>实例</p>
<pre><code class="language-java">public class Singleton {  
    private static Singleton instance;  
    private Singleton (){}  
    public static synchronized Singleton getInstance() {  
    if (instance == null) {  
        instance = new Singleton();  
    }  
    return instance;  
    }  
}
</code></pre>
<h4 id="饿汉模式">饿汉模式</h4>
<p>是否 Lazy 初始化：否</p>
<p>是否多线程安全：是</p>
<p>实现难度：易</p>
<p>描述：这种方式比较常用，但容易产生垃圾对象。<br>
优点：没有加锁，执行效率会提高。<br>
缺点：类加载时就初始化，浪费内存。<br>
它基于 <code>classloader</code> 机制避免了多线程的同步问题，不过，<code>instance</code> 在类装载时就实例化，虽然导致类装载的原因有很多种，在单例模式中大多数都是调用 <code>getInstance</code> 方法， 但是也不能确定有其他的方式（或者其他的静态方法）导致类装载，这时候初始化 <code>instance</code> 显然没有达到 lazy loading 的效果。</p>
<p>实例</p>
<pre><code class="language-java">public class Singleton {  
    private static Singleton instance = new Singleton();  
    private Singleton (){}  
    public static Singleton getInstance() {  
    return instance;  
    }  
}
</code></pre>
<h3 id="资料引用">资料引用</h3>
<p><a href="https://www.runoob.com/design-pattern/singleton-pattern.html">菜鸟教程</a></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Hello Gridea]]></title>
        <id>https://blog.lzw-723.xyz/post/hello-gridea/</id>
        <link href="https://blog.lzw-723.xyz/post/hello-gridea/">
        </link>
        <updated>2018-12-11T16:00:00.000Z</updated>
        <summary type="html"><![CDATA[<p>👏  欢迎使用 <strong>Gridea</strong> ！<br>
✍️  <strong>Gridea</strong> 一个静态博客写作客户端。你可以用它来记录你的生活、心情、知识、笔记、创意... ...</p>
]]></summary>
        <content type="html"><![CDATA[<p>👏  欢迎使用 <strong>Gridea</strong> ！<br>
✍️  <strong>Gridea</strong> 一个静态博客写作客户端。你可以用它来记录你的生活、心情、知识、笔记、创意... ...</p>
<!-- more -->
<p><a href="https://github.com/getgridea/gridea">Github</a><br>
<a href="https://gridea.dev/">Gridea 主页</a><br>
<a href="http://fehey.com/">示例网站</a></p>
<h2 id="特性">特性👇</h2>
<p>📝  你可以使用最酷的 <strong>Markdown</strong> 语法，进行快速创作</p>
<p>🌉  你可以给文章配上精美的封面图和在文章任意位置插入图片</p>
<p>🏷️  你可以对文章进行标签分组</p>
<p>📋  你可以自定义菜单，甚至可以创建外部链接菜单</p>
<p>💻  你可以在 <strong>Windows</strong>，<strong>MacOS</strong> 或 <strong>Linux</strong> 设备上使用此客户端</p>
<p>🌎  你可以使用 <strong>𝖦𝗂𝗍𝗁𝗎𝖻 𝖯𝖺𝗀𝖾𝗌</strong> 或 <strong>Coding Pages</strong> 向世界展示，未来将支持更多平台</p>
<p>💬  你可以进行简单的配置，接入 <a href="https://github.com/gitalk/gitalk">Gitalk</a> 或 <a href="https://github.com/SukkaW/DisqusJS">DisqusJS</a> 评论系统</p>
<p>🇬🇧  你可以使用<strong>中文简体</strong>或<strong>英语</strong></p>
<p>🌁  你可以任意使用应用内默认主题或任意第三方主题，强大的主题自定义能力</p>
<p>🖥  你可以自定义源文件夹，利用 OneDrive、百度网盘、iCloud、Dropbox 等进行多设备同步</p>
<p>🌱 当然 <strong>Gridea</strong> 还很年轻，有很多不足，但请相信，它会不停向前 🏃</p>
<p>未来，它一定会成为你离不开的伙伴</p>
<p>尽情发挥你的才华吧！</p>
<p>😘 Enjoy~</p>
]]></content>
    </entry>
</feed>