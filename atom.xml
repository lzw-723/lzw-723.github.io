<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://blog.lzw-723.xyz</id>
    <title>lzw-723&apos;s blog</title>
    <updated>2021-09-09T11:14:43.278Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://blog.lzw-723.xyz"/>
    <link rel="self" href="https://blog.lzw-723.xyz/atom.xml"/>
    <subtitle>要玩就玩得开心，这不代表我放弃</subtitle>
    <logo>https://blog.lzw-723.xyz/images/avatar.png</logo>
    <icon>https://blog.lzw-723.xyz/favicon.ico</icon>
    <rights>All rights reserved 2021, lzw-723&apos;s blog</rights>
    <entry>
        <title type="html"><![CDATA[《Moe Era》 - 时代潮流中不值一提的我]]></title>
        <id>https://blog.lzw-723.xyz/post/moe-era-ren-ying-dang-gan-jin-de-chong-fen-de-sheng-huo/</id>
        <link href="https://blog.lzw-723.xyz/post/moe-era-ren-ying-dang-gan-jin-de-chong-fen-de-sheng-huo/">
        </link>
        <updated>2021-09-08T11:43:47.000Z</updated>
        <summary type="html"><![CDATA[<p>这是一个深刻的、奇妙的故事。过了一个小时，就像只过了几秒。</p>
]]></summary>
        <content type="html"><![CDATA[<p>这是一个深刻的、奇妙的故事。过了一个小时，就像只过了几秒。</p>
<!-- more -->
<h2 id="初识">初识</h2>
<p>Steam商店界面简介：</p>
<blockquote>
<p>进入可爱的东西的时代吧！这个世界什么都有，只缺少一个能够解救四个美女的英雄。这个英雄会是你吗？</p>
</blockquote>
<p>Steam游戏评测摘选：</p>
<blockquote>
<p>在游戏的结局，就像是作者站在街道上对过往的行人们微笑致意；“你可千万不要再这样过下去了”。而结尾希望我们无论是去做什么，要对自己选择有意义的生活，无论平淡与否，为之改变自我，认识自我，找到自我的价值，即使平淡也是幸福的。</p>
</blockquote>
<blockquote>
<p>如果你是冲着“免费‘”色情内容”“恋爱模拟”这几个标签来的，仅此而已，那就请先改变你的想法，否则你会得不到你想要的，这游戏给不了你，不如去色情分区自己买。</p>
</blockquote>
<blockquote>
<p>噢上帝，你绝对不会相信我竟然在一款免费的游戏里看见了动态背景CG，以及天马行空的立绘展现方式，甚至还穿插有通过选择组合出一款属于你自己的蛋糕的创意内容。欧美游戏制作者们不拘一格的想象力让我看见了不同于日产galgame的更多可行性，这仅是我游玩半个小时的直观感受！</p>
</blockquote>
<blockquote>
<p>如果我是作者，做一款表现自己的游戏大概如此，把自己想法分成好几个家伙，中间塞点福利，免费让大家认识自己。</p>
</blockquote>
<h2 id="体验">体验</h2>
<table>
<thead>
<tr>
<th>项目</th>
<th>分数</th>
</tr>
</thead>
<tbody>
<tr>
<td>画面</td>
<td>⭐⭐⭐⭐</td>
</tr>
<tr>
<td>剧情</td>
<td>⭐⭐⭐⭐⭐</td>
</tr>
<tr>
<td>翻译</td>
<td>⭐⭐⭐</td>
</tr>
<tr>
<td>音乐</td>
<td>⭐⭐⭐⭐</td>
</tr>
</tbody>
</table>
<p>虽然我更喜欢日系动漫画风，但本作画面在细细品味一番后，别有风味，说不上特别优秀，为游戏加分没得说。动态背景、CG配合情节确实惊艳。<br>
<img src="https://steamuserimages-a.akamaihd.net/ugc/1751309932144390345/08D74ADE48F714A8C96641A2B6FCD1C7F692B32B/?imw=5000&amp;imh=5000&amp;ima=fit&amp;impolicy=Letterbox&amp;imcolor=%23000000&amp;letterbox=false" alt="人物情感在画面中的表达" loading="lazy"><br>
本作的音乐风格偏空灵，不免让我联想起DDLC。<s>事实证明不过是虚惊一场</s><br>
有几段音乐很有俄罗斯风格。<br>
弹钢琴的剧情让我记住了<strong>舒曼</strong>和他的<em>梦幻曲</em>。</p>
<iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width=max height=86 src="//music.163.com/outchain/player?type=2&id=1434268573&auto=1&height=66"></iframe>
<p>原谅我对音乐的无知（笑）。<br>
<img src="https://steamuserimages-a.akamaihd.net/ugc/781877465267243716/D9D9ABE9036A8640DCE6B79DEA9888FA3B9D6CB5/?imw=5000&amp;imh=5000&amp;ima=fit&amp;impolicy=Letterbox&amp;imcolor=%23000000&amp;letterbox=false" alt="无可挑剔的古典（？）音乐情节" loading="lazy"><br>
游戏用四天来映射一生，其余的人生用几张桌面的变迁代替。<br>
从游戏中看，除了一生中最精彩的一小段时间，其余的时光不值一提。<br>
但现实中的人生，像我一样，也许从不会出彩，能一眼望到死。<br>
<img src="https://steamuserimages-a.akamaihd.net/ugc/784129913445095821/3BC2201551B68E2FBCC726B74CCA7B5A25C62427/?imw=1920&amp;&amp;ima=fit&amp;impolicy=Letterbox&amp;imcolor=%23000000&amp;letterbox=false" alt="人生如梦" loading="lazy"><br>
游戏支持<code>中、英、俄、日</code>四种语言，有的文本翻译的十分接地气，有的又像是机翻一样。<br>
这是唯一扣分的地方。<s>不知道是不是刻意而为之</s><br>
<img src="https://i.niupic.com/images/2021/09/09/9uWl.png" alt="我操.jpg" loading="lazy"><br>
<img src="https://i.niupic.com/images/2021/09/09/9uWf.png" alt="疑似机翻" loading="lazy"></p>
<h2 id="资料">资料</h2>
<ol>
<li><a href="https://zh.wikipedia.org/wiki/%E7%BD%97%E4%BC%AF%E7%89%B9%C2%B7%E8%88%92%E6%9B%BC">舒曼 - 维基百科</a></li>
<li><a href="https://music.163.com/song?id=1434268573">舒曼: 《童年情景》梦幻曲 - Piano lullaby classic (클래식 기타의 향기) - 网易云音乐</a></li>
</ol>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[C语言教程 - for循环]]></title>
        <id>https://blog.lzw-723.xyz/post/c-yu-yan-jiao-cheng-for-xun-huan/</id>
        <link href="https://blog.lzw-723.xyz/post/c-yu-yan-jiao-cheng-for-xun-huan/">
        </link>
        <updated>2021-09-04T22:51:28.000Z</updated>
        <summary type="html"><![CDATA[<p>C语言中的for循环非常简单。</p>
]]></summary>
        <content type="html"><![CDATA[<p>C语言中的for循环非常简单。</p>
<!-- more -->
<h2 id="tutorial">Tutorial</h2>
<p>C语言中的for循环非常简单。你能用它创建一个循环—一块运行多次的代码块。<br>
for循环需要一个用来迭代的变量，通常命名为<code>i</code>。</p>
<p>for循环能够做这些：</p>
<ul>
<li>用一个初始值初始化迭代器变量</li>
<li>检查迭代变量是否达到最终值</li>
<li>增加迭代变量的值</li>
</ul>
<p>如果想运行代码块10次，可以这样写：</p>
<pre><code>int i;
for (i = 0; i &lt; 10; i++) {
    printf(&quot;%d\n&quot;, i);
}
</code></pre>
<p>这段代码会打印从0到9的数字。</p>
<p>for循环能够用来获取数组的每一个值。要计算一个数组所有值的和，可以这样使用<code>i</code>：</p>
<pre><code>int array[10] = { 1, 2, 3, 4, 5, 6, 7, 8, 9, 10 };
int sum = 0;
int i;

for (i = 0; i &lt; 10; i++) {
    sum += array[i];
}

/* 求a[0]到a[9]的和 */
printf(&quot;Sum of the array is %d\n&quot;, sum);
</code></pre>
<h2 id="exercise">Exercise</h2>
<p>计算数组array的阶乘（从array[0]乘到array[9]）。</p>
<h2 id="tutorial-code">Tutorial Code</h2>
<pre><code>#include &lt;stdio.h&gt;

int main() {
  int array[] = { 1, 2, 3, 4, 5, 6, 7, 8, 9, 10 };
  int factorial = 1;
  int i;

  /* 在这里使用for循环计算阶乘*/

  printf(&quot;10! is %d.\n&quot;, factorial);
}
</code></pre>
<h2 id="expected-output">Expected Output</h2>
<pre><code>10! is 3628800.
</code></pre>
<h2 id="solution">Solution</h2>
<pre><code>#include &lt;stdio.h&gt;

int main() {
  int array[] = { 1, 2, 3, 4, 5, 6, 7, 8, 9, 10 };
  int factorial = 1;

  int i;

  for(i=0;i&lt;10;i++){
    factorial *= array[i];
  }

  printf(&quot;10! is %d.\n&quot;, factorial);
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[C语言教程 - 字符串]]></title>
        <id>https://blog.lzw-723.xyz/post/c-yu-yan-jiao-cheng-zi-fu-chuan/</id>
        <link href="https://blog.lzw-723.xyz/post/c-yu-yan-jiao-cheng-zi-fu-chuan/">
        </link>
        <updated>2021-08-24T05:36:19.000Z</updated>
        <summary type="html"><![CDATA[<p>C语言中的字符串实际上是字符数组。</p>
]]></summary>
        <content type="html"><![CDATA[<p>C语言中的字符串实际上是字符数组。</p>
<h2 id="-more-tutorial"><!-- more --><br>
Tutorial</h2>
<h3 id="字符串的定义">字符串的定义</h3>
<p>C语言中的字符串实际上是字符数组。尽管使用指针是C语言中的高级课题，后面会详细解释，先使用指向字符数组的指针来定义简单的字符串，方法如下：</p>
<pre><code>char * name = &quot;John Smith&quot;;
</code></pre>
<p>这个方法创建了一个只能读取的字符串。<br>
如果希望定义一个可以被操作的字符串，需要定义为一个字符数组。</p>
<pre><code>char name[] = &quot;John Smith&quot;;
</code></pre>
<p>符号不同是因为它分配了一个数组变量，所以可以对它进行操作。方括号<code>[]</code>告诉编译器自动计算数组的大小。实际上是否指明大小都是一样的，字符串的长度为字符数组的大小减一。</p>
<pre><code>char name[] = &quot;John Smith&quot;;
/* 与下面的意思相同 */
char name[11] = &quot;John Smith&quot;;
</code></pre>
<p>尽管字符串<code>John Smith</code>正好是10个字符长，但需要加一，是为了表明字符串的结束。一个特殊的char（等于0）表示字符串的结束。字符串的结尾被标记出来是因为程序不知道字符串的长度——只有编译器根据代码才知道。</p>
<h3 id="用printf格式化字符串">用printf格式化字符串</h3>
<p>可以使用<code>printf</code>方法将一个字符串与其他字符串一起格式化，具体方法如下：</p>
<pre><code>char * name = &quot;John Smith&quot;;
int age = 27;

/* 打印'John Smith is 27 years old.' */
printf(&quot;%s is %d years old.\n&quot;, name, age);
</code></pre>
<p>请注意，在打印字符串时，必须添加一个换行符（<code>\n</code>）来让下一个<code>printf</code>语句打印在一个新行中。</p>
<h3 id="字符串长度">字符串长度</h3>
<p>函数<code>strlen</code>返回作为参数传递的字符串的长度。</p>
<pre><code>char * name = &quot;Nikhil&quot;;
printf(&quot;%d\n&quot;,strlen(name));        
</code></pre>
<h3 id="比较字符串">比较字符串</h3>
<p>函数<code>strncmp</code>对两个字符串进行比较。如果相同，返回数字0；如果不同，返回其他数字。<br>
参数是要比较的两个字符串，以及最大比较长度。这个函数还有一个不安全的版本，叫做<code>strcmp</code>，不建议使用。例如：</p>
<pre><code>char * name = &quot;John&quot;;

if (strncmp(name, &quot;John&quot;, 4) == 0) {
    printf(&quot;Hello, John!\n&quot;);
} else {
    printf(&quot;You are not John. Go away.\n&quot;);
}
</code></pre>
<h3 id="字符串拼接">字符串拼接</h3>
<p>函数<code>strncat</code>将src字符串的前n个字符添加到目标字符串中，其中n为min(n,length(src))。<br>
传递的参数是目标字符串、源字符串和n——要增添的最大字符数。例如：</p>
<pre><code>char dest[20]=&quot;Hello&quot;;
char src[20]=&quot;World&quot;;
strncat(dest,src,3);
printf(&quot;%s\n&quot;,dest);
strncat(dest,src,20);
printf(&quot;%s\n&quot;,dest);
</code></pre>
<h2 id="exercise">Exercise</h2>
<p>使用指针定义字符串<code>first_name</code>，其值为<code>John</code>，使用字符数组定义字符串<code>last_name</code>，其值为<code>Doe</code>。</p>
<h2 id="tutorial-code">Tutorial Code</h2>
<pre><code>#include &lt;stdio.h&gt;
#include &lt;string.h&gt;
int main() {
  /* 定义first_name */
  /* 定义last_name */
  char name[100];

  last_name[0] = 'B';
  sprintf(name, &quot;%s %s&quot;, first_name, last_name);
  if (strncmp(name, &quot;John Boe&quot;, 100) == 0) {
      printf(&quot;Done!\n&quot;);
  }
  name[0]='\0';
  strncat(name,first_name,4);
  strncat(name,last_name,20);
  printf(&quot;%s\n&quot;,name);
  return 0;
}
</code></pre>
<h2 id="expected-output">Expected Output</h2>
<pre><code>Done!
JohnBoe
</code></pre>
<h2 id="solution">Solution</h2>
<pre><code>#include &lt;stdio.h&gt;
#include &lt;string.h&gt;
int main() {
  char * first_name = &quot;John&quot;;
  char last_name[] = &quot;Doe&quot;;
  char name[100];

  last_name[0] = 'B';
  sprintf(name, &quot;%s %s&quot;, first_name, last_name);
  if (strncmp(name, &quot;John Boe&quot;, 100) == 0) {
      printf(&quot;Done!\n&quot;);
  }
  name[0]='\0';
  strncat(name,first_name,4);
  strncat(name,last_name,20);
  printf(&quot;%s\n&quot;,name);
  return 0;
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[C语言教程 - 条件语句]]></title>
        <id>https://blog.lzw-723.xyz/post/c-yu-yan-jiao-cheng-tiao-jian-yu-ju/</id>
        <link href="https://blog.lzw-723.xyz/post/c-yu-yan-jiao-cheng-tiao-jian-yu-ju/">
        </link>
        <updated>2021-08-06T07:43:55.000Z</updated>
        <summary type="html"><![CDATA[<p>生活中我们必须做出决定。要根据自己的需要来做出决定，程序也是如此。</p>
]]></summary>
        <content type="html"><![CDATA[<p>生活中我们必须做出决定。要根据自己的需要来做出决定，程序也是如此。</p>
<!-- more -->
<h2 id="tutorial">Tutorial</h2>
<h3 id="决策">决策</h3>
<p>生活中我们必须做出决定。要根据自己的需要来做出决定，程序也是如此。</p>
<p>下面是C语言中决策结构的一般形式。</p>
<pre><code>int target = 10;
if (target == 10) {
    printf(&quot;Target is equal to 10&quot;);
}
</code></pre>
<h3 id="if语句"><code>if</code>语句</h3>
<p><code>if</code>语句检查一个表达式是<code>真</code>还是<code>假</code>，并根据结果执行不同的代码。</p>
<p>使用了<code>==</code>运算符判断两个变量是否相等，就像上面的例子一样。</p>
<p>也可以用不等式运算符来判断。例如——</p>
<pre><code>int foo = 1;
int bar = 2;

if (foo &lt; bar) {
    printf(&quot;foo is smaller than bar.&quot;);
}

if (foo &gt; bar) {
    printf(&quot;foo is greater than bar.&quot;);
}
</code></pre>
<p>使用<code>else</code>关键字在表达式为<code>false</code>时退出代码。</p>
<pre><code>int foo = 1;
int bar = 2;

if (foo &lt; bar) {
    printf(&quot;foo is smaller than bar.&quot;);
} else {
    printf(&quot;foo is greater than bar.&quot;);
}
</code></pre>
<p>有两个以上的结果可供选择的情况下，可以将多个<code>if</code> <code>else</code>语句<code>连锁</code>。</p>
<pre><code>int foo = 1;
int bar = 2;

if (foo &lt; bar) {
    printf(&quot;foo is smaller than bar.&quot;);
} else if (foo == bar) {
    printf(&quot;foo is equal to bar.&quot;);
} else {
    printf(&quot;foo is greater than bar.&quot;);
}
</code></pre>
<p>也可以嵌套<code>if</code> <code>else</code>语句。</p>
<pre><code>int peanuts_eaten = 22;
int peanuts_in_jar = 100;
int max_peanut_limit = 50;

if (peanuts_in_jar &gt; 80) {
    if (peanuts_eaten &lt; max_peanut_limit) {
        printf(&quot;Take as many peanuts as you want!\n&quot;);
    }
} else {
    if (peanuts_eaten &gt; peanuts_in_jar) {
        printf(&quot;You can't have anymore peanuts!\n&quot;);
    }
    else {
        printf(&quot;Alright, just one more peanut.\n&quot;);
    }
}
</code></pre>
<p>两个或多个表达式可以使用逻辑运算符检查是否都为<code>真</code>，或是否其中一个为<code>真</code>。使用AND运算符<code>&amp;&amp;</code>检查两个表达式是否都为<code>真</code>。使用OR运算符<code>||</code>检查是否至少有一个表达式为<code>真</code>。</p>
<pre><code>int foo = 1;
int bar = 2;
int moo = 3;

if (foo &lt; bar &amp;&amp; moo &gt; bar) {
    printf(&quot;foo is smaller than bar AND moo is larger than bar.&quot;);
}

if (foo &lt; bar || moo &gt; bar) {
    printf(&quot;foo is smaller than bar OR moo is larger than bar.&quot;);
}
</code></pre>
<p>NOT运算符<code>!</code>类似：</p>
<pre><code>int target = 9;
if (target != 10) {
    printf(&quot;Target is not equal to 10&quot;);
}
</code></pre>
<h2 id="exercise">Exercise</h2>
<p>练习，在<code>guessNumber</code>函数中构建一个<code>if</code>语句，检查数字<code>guess</code>是否等于555。如果是，在该函数内用<code>printf</code>打印出 &quot;正确。你猜对了！&quot;。如果<code>guess</code>小于555，用<code>printf</code>打印出 &quot;你猜的低了&quot;。如果<code>guess</code>大于555，用<code>printf</code>打印出 &quot;你猜的高了&quot;。</p>
<ul>
<li><strong>重要</strong>：不要忘记在要打印的字符串末尾添加一个换行符<code>\n</code>。</li>
</ul>
<h2 id="tutorial-code">Tutorial Code</h2>
<pre><code>#include &lt;stdio.h&gt;

void guessNumber(int guess) {
    // TODO：在这里写代码
}

int main() {
    guessNumber(500);
    guessNumber(600);
    guessNumber(555);
}
</code></pre>
<h2 id="expected-output">Expected Output</h2>
<p>Your guess is too low.<br>
Your guess is too high.<br>
Correct. You guessed it!</p>
<h2 id="solution">Solution</h2>
<pre><code>#include &lt;stdio.h&gt;

void guessNumber(int guess) {
    // TODO：在这里写代码
    if (guess &lt; 555) {
        printf(&quot;Your guess is too low.\n&quot;);
    } else if (guess &gt; 555) {
        printf(&quot;Your guess is too high.\n&quot;);
    } else {
        printf(&quot;Correct. You guessed it!\n&quot;);
    }
}

int main() {
    guessNumber(500);
    guessNumber(600);
    guessNumber(555);
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[C语言教程 - 多维数组]]></title>
        <id>https://blog.lzw-723.xyz/post/c-yu-yan-jiao-cheng-duo-wei-shu-zu/</id>
        <link href="https://blog.lzw-723.xyz/post/c-yu-yan-jiao-cheng-duo-wei-shu-zu/">
        </link>
        <updated>2021-08-06T03:19:14.000Z</updated>
        <summary type="html"><![CDATA[<p>C语言可以创建和使用多维数组。</p>
]]></summary>
        <content type="html"><![CDATA[<p>C语言可以创建和使用多维数组。</p>
<!-- more -->
<h2 id="tutorial">Tutorial</h2>
<p>在前一节<a href="https://www.learn-c.org/zh/%E6%95%B0%E7%BB%84">数组</a>教程中讲解了如何使用数组。这些数组都是一维的，但C语言可以创建和使用多维数组。下面是一个多维数组声明的一般形式。</p>
<pre><code>type name[size1][size2]...[sizeN];
</code></pre>
<p>这里有一个基本示例参考——</p>
<pre><code>int foo[1][2][3];
</code></pre>
<p>也可以这样——</p>
<pre><code>char vowels[1][5] = {
	{'a', 'e', 'i', 'o', 'u'}
};
</code></pre>
<h3 id="二维数组">二维数组</h3>
<p>二维数组是最简单的多维数组。一个二维数组差不多是一个一维数组的列表。要声明一个大小为[ x ][ y ]的二维整数数组，你可以这样写——</p>
<pre><code>type arrayName [x][y];
</code></pre>
<p>其中<strong>type</strong>可以是C语言的任何数据类型（int, char, long, long long, double, 等等），<strong>arrayName</strong>是一个有效的C语言标识符，或变量。一个二维数组可以被认为是一个表，它有[ x ]行和[ y ]列。可以这样想象一个包含三行四列的二维数组a——</p>
<figure data-type="image" tabindex="1"><img src="https://www.tutorialspoint.com/cprogramming/images/two_dimensional_arrays.jpg" alt="Table 1A" loading="lazy"></figure>
<p>像这样，数组a中的每个元素都由**a[i][j]**形式的元素名来识别，其中'a'是数组的名称，'i'和'j'是独一无二的索引，合起来也就是'a'中的一个元素的意思。</p>
<p>其实，不需要把[ x ]值真的放进去，因为如果这样做——</p>
<pre><code>char vowels[][5] = {
	{'A', 'E', 'I', 'O', 'U'},
	{'a', 'e', 'i', 'o', 'u'}
};
</code></pre>
<p>编译器已经知道有两个 &quot;维度&quot;，但是，<strong>需要</strong>一个[ y ]值！! 编译器很聪明，但是它<em>不会知道</em>你在维度中使用了多少个整数、字符、浮点数，或者其他。请牢记这一点。</p>
<h3 id="初始化二维数组">初始化二维数组</h3>
<p>多维数组中可以为每一行指定[]内的值。下面是一个3行4列的数组。为了方便，你可以不写3，不填写行数，它仍然可以工作。</p>
<pre><code>int a[3][4] = {  
   {0, 1, 2, 3} ,   /*  初始化索引为0的行 */
   {4, 5, 6, 7} ,   /*  初始化索引为1的行 */
   {8, 9, 10, 11}   /*  初始化索引为2的行 */
};
</code></pre>
<p>里面的大括号表示想要的行，是可选的。下面的初始化效果与前面的例子相同——</p>
<pre><code>int a[3][4] = {0,1,2,3,4,5,6,7,8,9,10,11};
</code></pre>
<h3 id="访问二维数组中的元素">访问二维数组中的元素</h3>
<p>通过使用下标来访问二维数组中的元素，即使用数组的行索引和列索引。例如——</p>
<pre><code>int val = a[2][3];
</code></pre>
<p>上述语句将从数组中取出第3行第4个元素。</p>
<h2 id="exercise">Exercise</h2>
<p>尝试找出五名学生数学和物理两门学科的平均分。使用一个名为<code>grades</code>的二维数组去完成。数学对应的分数将被存储在第一行（<code>grades[0]</code>），物理对应的分数将被存储在第二行（<code>grades[1]</code>）。完成以下剩余步骤，执行这个程序。</p>
<ul>
<li>将成绩声明为一个二维整数数组</li>
<li>通过指定终止条件来完成for循环</li>
<li>计算各科的平均分</li>
</ul>
<h2 id="tutorial-code">Tutorial Code</h2>
<pre><code>#include &lt;stdio.h&gt;

int main() {
	/* TODO：在此声明成绩二维数组 */
	float average;
	int i;
	int j;

	grades[0][0] = 80;
	grades[0][1] = 70;
	grades[0][2] = 65;
	grades[0][3] = 89;
	grades[0][4] = 90;

	grades[1][0] = 85;
	grades[1][1] = 80;
	grades[1][2] = 80;
	grades[1][3] = 82;
	grades[1][4] = 87;

	/* TODO：通过指定终止条件来完成for循环 */
	for (i = 0; i &lt; ; i++) {
		average = 0;
		for (j = 0; j &lt; ; j++) {
			average += grades[i][j];
		}

		/* TODO：计算学科i的平均分 */
		printf(&quot;The average marks obtained in subject %d is: %.2f\n&quot;, i, average);
	}

	return 0;
}
</code></pre>
<h2 id="expected-output">Expected Output</h2>
<pre><code>The average marks obtained in subject 0 is: 78.80
The average marks obtained in subject 1 is: 82.80
</code></pre>
<h2 id="solution">Solution</h2>
<pre><code>#include &lt;stdio.h&gt;

int main() {
	int grades[2][5];
	float average;
	int i;
	int j;

	grades[0][0] = 80;
	grades[0][1] = 70;
	grades[0][2] = 65;
	grades[0][3] = 89;
	grades[0][4] = 90;

	grades[1][0] = 85;
	grades[1][1] = 80;
	grades[1][2] = 80;
	grades[1][3] = 82;
	grades[1][4] = 87;

	for (i = 0; i &lt; 2; i++) {
		average = 0;
		
		for (j = 0; j &lt; 5; j++) {
			average += grades[i][j];
		}

		average /= 5.0;
		printf(&quot;The average marks obtained in subject %d is: %.2f\n&quot;, i, average);
	}

	return 0;
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[C语言教程 - 数组]]></title>
        <id>https://blog.lzw-723.xyz/post/c-yu-yan-jiao-cheng-shu-zu/</id>
        <link href="https://blog.lzw-723.xyz/post/c-yu-yan-jiao-cheng-shu-zu/">
        </link>
        <updated>2021-08-06T01:55:39.000Z</updated>
        <summary type="html"><![CDATA[<p>数组是一种特殊的变量，它可以在同一个变量名下容纳多个值，并以索引的形式组织起来。</p>
]]></summary>
        <content type="html"><![CDATA[<p>数组是一种特殊的变量，它可以在同一个变量名下容纳多个值，并以索引的形式组织起来。</p>
<!-- more -->
<h2 id="tutorial">Tutorial</h2>
<p>数组是一种特殊的变量，它可以在同一个变量名下容纳多个值，并以索引的形式组织起来。<br>
数组的定义采用了非常简单的语法：</p>
<pre><code>/* 定义了一个由10个整数组成的数组 */
int numbers[10];
</code></pre>
<p>从数组中访问一个数字也是用同样的语法完成的。<br>
请注意，C语言中的数组是以零开头的，这意味着如果定义了一个大小为10的数组，那么数组单元0到9（包括）都被定义了。<br>
<code>numbers[10]</code>不存在。</p>
<pre><code>int numbers[10];

/* 填充该数组 */
numbers[0] = 10;
numbers[1] = 20;
numbers[2] = 30;
numbers[3] = 40;
numbers[4] = 50;
numbers[5] = 60;
numbers[6] = 70;

/* 打印数组中的第7个数字，其索引为6 */
printf(&quot;The 7th number in the array is %d&quot;, numbers[6]);
</code></pre>
<p>数组只能有一种类型的变量，因为它们被实现为计算机内存中的一个数值序列。<br>
正因如此，访问一个特定的数组单元是非常高效的。</p>
<h2 id="exercise">Exercise</h2>
<ul>
<li>下面的代码不能编译，因为缺少<code>grades</code>变量。</li>
<li>其中一个成绩缺失。你能定义它，使平均成绩为85分吗？</li>
</ul>
<h2 id="tutorial-code">Tutorial Code</h2>
<pre><code>#include &lt;stdio.h&gt;

int main() {
  /* TODO：在这里定义成绩变量 */
  int average;

  grades[0] = 80;
  /* TODO：定义缺失的成绩，以使平均分达到85。 */
  grades[2] = 90;

  average = (grades[0] + grades[1] + grades[2]) / 3;
  printf(&quot;The average of the 3 grades is: %d&quot;, average);

  return 0;
}
</code></pre>
<h2 id="expected-output">Expected Output</h2>
<pre><code>The average of the 3 grades is: 85
</code></pre>
<h2 id="solution">Solution</h2>
<pre><code>#include &lt;stdio.h&gt;

int main() {
  /* TODO：在这里定义成绩变量 */
  int grades[3];
  int average;

  grades[0] = 80;
  /* TODO：定义缺失的成绩，以使平均分达到85。 */
  grades[1] = 85;
  grades[2] = 90;

  average = (grades[0] + grades[1] + grades[2]) / 3;
  printf(&quot;The average of the 3 grades is: %d&quot;, average);

  return 0;
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[C语言教程 - 变量和类型]]></title>
        <id>https://blog.lzw-723.xyz/post/c-yu-yan-jiao-cheng-bian-liang-he-lei-xing/</id>
        <link href="https://blog.lzw-723.xyz/post/c-yu-yan-jiao-cheng-bian-liang-he-lei-xing/">
        </link>
        <updated>2021-08-06T01:46:08.000Z</updated>
        <summary type="html"><![CDATA[<p>C语言有很多种类型的变量，但只有几个基本类型。</p>
]]></summary>
        <content type="html"><![CDATA[<p>C语言有很多种类型的变量，但只有几个基本类型。</p>
<!-- more -->
<h2 id="tutorial">Tutorial</h2>
<h3 id="数据类型">数据类型</h3>
<p>C语言有很多种类型的变量，但只有几个基本类型。</p>
<ul>
<li>整数——可以是正数或负数的整数。使用<code>char</code>、<code>int</code>、<code>short</code>、<code>long</code>或<code>long long</code>来定义。</li>
<li>无符号整数——只能是正数的整数。使用<code>unsigned char</code>、<code>unsigned int</code>、<code>unsigned short</code>、<code>unsigned long</code>或<code>unsigned long long</code>定义。</li>
<li>浮点数——实数（带小数的数字）。使用<code>float</code>和<code>double</code>来定义。</li>
<li>结构——将在后面的结构部分解释。</li>
</ul>
<p>不同类型的变量定义了它们的界限。一个<code>char</code>的范围只能从-128到127，而一个<code>long</code>的范围可以从-2,147,483,648到2,147,483,647（<code>long</code>和其他数字数据类型在不同的计算机上可能有另一个范围，例如——在64位计算机上从-9,223,372,036,854,775,808到9,223,372,036,854,775,807）。</p>
<p>请注意，C语言<em>没有</em>布尔类型。通常情况下，它是用下面的符号定义的。</p>
<pre><code>#define BOOL char
#define FALSE 0
#define TRUE 1
</code></pre>
<p>C语言使用字符数组来定义字符串，将在<code>字符串</code>部分进行解释。</p>
<h3 id="定义变量">定义变量</h3>
<p>通常使用<code>int</code>类型定义数字，它是一个<code>字</code>大小的整数，也就是程序的编译机器的默认数字大小。<br>
在今天的大多数计算机上，它是一个32位的数字，这意味着数字的范围可以从-2,147,483,648到2,147,483,647。</p>
<p>为了定义变量<code>foo</code>和<code>bar</code>，需要使用以下语法。</p>
<pre><code>int foo;
int bar = 1;
</code></pre>
<p>变量<code>foo</code>可以使用，但由于没有初始化它，我们不知道里面有什么。变量<code>bar</code>装着数字1。</p>
<p>现在，可以做一些数学运算。<br>
假设<code>a</code>、<code>b</code>、<code>c</code>、<code>d</code>和<code>e</code>是变量，可以简单地使用加、减和乘法运算符 在下面的代码中，给<code>a</code>分配一个新值：</p>
<pre><code>int a = 0, b = 1, c = 2, d = 3, e = 4;
a = b - c + d * e;
printf(&quot;%d&quot;, a); /* will print 1-2+3*4 = 11 */
</code></pre>
<h2 id="exercise">Exercise</h2>
<p>在下一个练习中，你将创建一个程序，打印出数字<code>a</code>、<code>b</code>和<code>c</code>的和。</p>
<h2 id="tutorial-code">Tutorial Code</h2>
<pre><code>#include &lt;stdio.h&gt;

int main() {
  int a = 3;
  float b = 4.5;
  double c = 5.25;
  float sum;

  /* 你的代码放在这里 */

  printf(&quot;The sum of a, b, and c is %f.&quot;, sum);
  return 0;
}
</code></pre>
<h2 id="expected-output">Expected Output</h2>
<pre><code>The sum of a, b, and c is 12.750000.
</code></pre>
<h2 id="solution">Solution</h2>
<pre><code>#include &lt;stdio.h&gt;

int main() {
  int a = 3;
  float b = 4.5;
  double c = 5.25;
  float sum;

  sum = a + b + c;

  printf(&quot;The sum of a, b, and c is %f.&quot;, sum);
  return 0;
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[C语言教程 - 你好，世界！]]></title>
        <id>https://blog.lzw-723.xyz/post/c-yu-yan-jiao-cheng-ni-hao-shi-jie/</id>
        <link href="https://blog.lzw-723.xyz/post/c-yu-yan-jiao-cheng-ni-hao-shi-jie/">
        </link>
        <updated>2021-08-06T01:06:56.000Z</updated>
        <summary type="html"><![CDATA[<p>虽然C语言被认为 &quot;难学&quot;，实际上C语言是一种非常简单的语言，功能强大。</p>
]]></summary>
        <content type="html"><![CDATA[<p>虽然C语言被认为 &quot;难学&quot;，实际上C语言是一种非常简单的语言，功能强大。</p>
<!-- more -->
<h2 id="tutorial">Tutorial</h2>
<h3 id="导言">导言</h3>
<p>C语言是一种通用的编程语言，它与机器的工作方式密切相关。<br>
理解计算机内存的工作方式是C语言编程的一个重要方面。<br>
虽然C语言被认为 &quot;难学&quot;，实际上C语言是一种非常简单的语言，功能强大。</p>
<p>C语言是一种非常常见的编程语言，它是许多应用程序的开发语言，如Windows、Python解释器、Git和许多其他编程语言。</p>
<p>C语言是一种编译语言——这意味着为了运行它，编译器（例如GCC或Visual Studio）必须将编写的代码进行处理，然后创建一个可执行文件。这个文件可以被执行，会做我们想让程序做的事情。</p>
<h3 id="第一个程序">第一个程序</h3>
<p>每个C语言程序都使用库，它赋予执行必要功能的能力。例如，最基本的函数<code>printf</code>，用于向屏幕打印输出，定义在 <code>stdio.h</code>头文件中。</p>
<p>为了在程序中增加运行<code>printf</code>命令的能力，必须在第一行代码中添加以下include指令。</p>
<pre><code>#include &lt;stdio.h&gt;
</code></pre>
<p>代码的第二部分是要写的实际代码。将要运行的第一段代码将始终在<code>main</code>函数中。</p>
<pre><code>int main() {
  ...你的代码放在这里
}
</code></pre>
<p><code>int</code>关键字表示函数<code>main</code>将返回一个整数——一个简单的数字。该函数返回的数字表明编写的程序是否正常工作。<br>
如果想表达代码运行成功，将返回数字0。一个大于0的数字将意味着编写的程序运行失败。</p>
<p>在本教程中，将返回0以表示程序是成功的：</p>
<pre><code>return 0;
</code></pre>
<p>请注意，C语言中的每个语句都必须以分号结束，这样编译器才知道一个新的语句已经开始。</p>
<p>最后不能不提，需要调用<code>printf</code>函数来打印句子。</p>
<h2 id="exercise">Exercise</h2>
<p>改写下面的程序，使其打印输出<code>Hello, World!</code>。</p>
<h2 id="tutorial-code">Tutorial Code</h2>
<pre><code>#include &lt;stdio.h&gt;

int main() {
  printf(&quot;Goodbye, World!&quot;);
  return 0;
}
</code></pre>
<h2 id="expected-output">Expected Output</h2>
<pre><code>Hello, World!
</code></pre>
<h2 id="solution">Solution</h2>
<pre><code>#include &lt;stdio.h&gt;

int main() {
  printf(&quot;Hello, World!&quot;);
  return 0;
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[C语言教程 - 目录]]></title>
        <id>https://blog.lzw-723.xyz/post/c-yu-yan-jiao-cheng-mu-lu/</id>
        <link href="https://blog.lzw-723.xyz/post/c-yu-yan-jiao-cheng-mu-lu/">
        </link>
        <updated>2021-08-06T00:55:20.000Z</updated>
        <summary type="html"><![CDATA[<blockquote>
<p>本教程是笔者对<a href="https://github.com/ronreiter/interactive-tutorials/blob/master/tutorials/learn-c.org/">learn-c.org</a>的翻译，详见<a href="https://github.com/ronreiter/interactive-tutorials/pull/611">Added learn-c.org Chinese translation</a>，转载后交互式内容缺失，可以前往<a href="https://www.learn-c.org/zh/">learn-c.org 中文版</a>查看。</p>
</blockquote>
]]></summary>
        <content type="html"><![CDATA[<blockquote>
<p>本教程是笔者对<a href="https://github.com/ronreiter/interactive-tutorials/blob/master/tutorials/learn-c.org/">learn-c.org</a>的翻译，详见<a href="https://github.com/ronreiter/interactive-tutorials/pull/611">Added learn-c.org Chinese translation</a>，转载后交互式内容缺失，可以前往<a href="https://www.learn-c.org/zh/">learn-c.org 中文版</a>查看。</p>
</blockquote>
<!-- more -->
<h2 id="欢迎">欢迎</h2>
<p>欢迎来到learn-c.org的免费交互式C语言教程。</p>
<p>这个网站都是为每个希望学习C语言的人准备的，无论你是否是一个有经验的程序员。</p>
<p>不需要下载任何东西——只需点击你想开始的章节，然后按照指示操作。祝您好运!</p>
<p>learn-c.org仍在建设中——如果你想贡献教程，请点击下方的<code>贡献教程</code>。</p>
<h3 id="基础学习">基础学习</h3>
<ul>
<li><a href="../c-yu-yan-jiao-cheng-ni-hao-shi-jie">你好，世界!</a></li>
<li><a href="../c-yu-yan-jiao-cheng-bian-liang-he-lei-xing">变量和类型</a></li>
<li><a href="../c-yu-yan-jiao-cheng-shu-zu">数组</a></li>
<li><a href="../c-yu-yan-jiao-cheng-duo-wei-shu-zu">多维数组</a></li>
<li><a href="../c-yu-yan-jiao-cheng-tiao-jian-yu-ju">条件语句</a></li>
<li><a href="../c-yu-yan-jiao-cheng-zi-fu-chuan">字符串</a></li>
<li><a href="../c-yu-yan-jiao-cheng-for-xun-huan">for循环</a></li>
<li>[[While loops]]</li>
<li>[[Functions]]</li>
<li>[[Static]]</li>
</ul>
<h3 id="进阶内容">进阶内容</h3>
<ul>
<li>[[Pointers]]</li>
<li>[[Structures]]</li>
<li>[[Function arguments by reference]]</li>
<li>[[Dynamic allocation]]</li>
<li>[[Arrays and Pointers]]</li>
<li>[[Recursion]]</li>
<li>[[Linked lists]]</li>
<li>[[Binary trees]]</li>
<li>[[Unions]]</li>
<li>[[Pointer Arithmetics]]</li>
<li>[[Function Pointers]]</li>
<li>[[Bitmasks]]</li>
</ul>
<h3 id="贡献教程">贡献教程</h3>
<p>在此阅读更多信息：[[Contributing Tutorials]]</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Java日志学习]]></title>
        <id>https://blog.lzw-723.xyz/post/java-ri-zhi-xue-xi/</id>
        <link href="https://blog.lzw-723.xyz/post/java-ri-zhi-xue-xi/">
        </link>
        <updated>2021-07-01T04:32:24.000Z</updated>
        <summary type="html"><![CDATA[<p>不要再滥用<code>System.out.println()</code>了</p>
]]></summary>
        <content type="html"><![CDATA[<p>不要再滥用<code>System.out.println()</code>了</p>
<!-- more -->
<hr>
<h2 id="日志概念">日志概念</h2>
<h3 id="日志是什么">日志是什么</h3>
<blockquote>
<p>生活中的日志是记录你生活的点点滴滴，让它把你内心的世界表露出来，更好的诠释自己的内心世界，而电脑里的日志可以是有价值的信息宝库，也可以是毫无价值的数据泥潭。</p>
</blockquote>
<p>网络设备、系统及服务程序等，在运作时都会产生一个叫<code>log</code>的事件记录；每一行日志都记载着日期、时间、使用者及动作等相关操作的描述。</p>
<h3 id="日志有什么优点">日志有什么优点</h3>
<p>输出日志，而不是用<code>System.out.println()</code>，有以下几个好处：</p>
<ol>
<li>可以设置输出样式，避免自己每次都写<code>&quot;ERROR: &quot; + var</code>；</li>
<li>可以设置输出级别，禁止某些级别输出。例如，只输出错误日志；</li>
<li>可以被重定向到文件，这样可以在程序运行结束后查看日志；</li>
<li>可以按包名控制日志级别，只输出某些包打的日志；</li>
<li>……</li>
</ol>
<p>总之就是十分友好。</p>
<hr>
<h2 id="java中的日志">Java中的日志</h2>
<h3 id="常见的日志工具">常见的日志工具</h3>
<ul>
<li>[日志实现]<code>Java</code>标准库内置的日志包<code>java.util.logging</code></li>
<li>[<strong>日志接口</strong>][不活跃]<code>Apache</code>软件基金会的<a href="https://commons.apache.org/proper/commons-logging/"><code>Commons Logging</code></a></li>
<li>[<strong>日志接口</strong>][<strong>活跃</strong>]<code>QOS.ch</code>的日志抽象<a href="http://www.slf4j.org/"><code>SLF4J</code></a></li>
<li>[日志实现][不活跃]<code>Apache</code>软件基金会的<a href="https://logging.apache.org/log4j/"><code>log4j</code></a></li>
<li>[日志实现][<strong>活跃</strong>]<code>QOS.ch</code>的<a href="https://logback.qos.ch/"><code>Logback</code></a></li>
</ul>
<h3 id="我的选择">我的选择</h3>
<p>截止当前(<em>2021年7月1日</em>)以上只有<code>SLF4J</code>和<code>Logback</code>近期(<strong>一个月内</strong>)还有<code>commit</code><br>
所以笔者做以下选择</p>
<ul>
<li><code>SLF4J</code> + <code>Logback</code></li>
</ul>
<h3 id="准备工作">准备工作</h3>
<h4 id="新建示例工程">新建示例工程</h4>
<p>笔者选择使用更为简单的<code>Maven</code>工程<br>
目录结构如下（已删去无关文件）</p>
<pre><code class="language-shell">│   pom.xml
│
├───src
    └───main
        └───java
            └───com
                └───example
                        App.java
</code></pre>
<p>唯一源代码文件<code>App.java</code></p>
<pre><code class="language-java">package com.example;

/**
 * Hello world!
 *
 */
public class App
{
    public static void main( String[] args )
    {
        System.out.println( &quot;Hello World!&quot; );
    }
}
</code></pre>
<h3 id="配置工程依赖">配置工程依赖</h3>
<pre><code class="language-xml">  &lt;dependencies&gt;
    &lt;!-- slf4j-api --&gt;
    &lt;dependency&gt;
      &lt;groupId&gt;org.slf4j&lt;/groupId&gt;
      &lt;artifactId&gt;slf4j-api&lt;/artifactId&gt;
      &lt;version&gt;1.7.31&lt;/version&gt;
    &lt;/dependency&gt;
    &lt;!-- logback --&gt;
    &lt;dependency&gt;
      &lt;groupId&gt;ch.qos.logback&lt;/groupId&gt;
      &lt;artifactId&gt;logback-core&lt;/artifactId&gt;
      &lt;version&gt;1.2.3&lt;/version&gt;
    &lt;/dependency&gt;
    &lt;!-- logback-classic（已含有对slf4j的集成包） --&gt;
    &lt;dependency&gt;
      &lt;groupId&gt;ch.qos.logback&lt;/groupId&gt;
      &lt;artifactId&gt;logback-classic&lt;/artifactId&gt;
      &lt;version&gt;1.2.3&lt;/version&gt;
    &lt;/dependency&gt;
  &lt;/dependencies&gt;
</code></pre>
<h2 id="上手">上手</h2>
<h3 id="最基本的用法">最基本的用法</h3>
<pre><code class="language-java">    public static void main(String[] args) {
        System.out.println(&quot;Hello World!&quot;);
        helloSLF4J();
    }

    public static void helloSLF4J() {
        Logger logger = LoggerFactory.getLogger(App.class);
        logger.info(&quot;Hello SLF4J!&quot;);
    }
</code></pre>
<p>控制台输出</p>
<pre><code class="language-shell">Hello World!
16:38:54.863 [main] INFO com.example.App - Hello SLF4J!
</code></pre>
<p>看到没，<code>时间 [线程] 日志等级 所在类 - 信息</code>的友善格式完胜直接<code>System.out.println()</code></p>
<h3 id="slf4j日志等级">SLF4J日志等级</h3>
<p>优先级由低到高：</p>
<ol>
<li>trace - 一般用来追踪详细的程序运行流</li>
<li>debug - 这类日志往往用在调试场景</li>
<li>info - 用来记录程序运行的一些关键信息</li>
<li>warn - 用来记录一些警告信息</li>
<li>error - 用来记录运行时的错误信息</li>
</ol>
<p>代码实例</p>
<pre><code class="language-java">        Logger logger = LoggerFactory.getLogger(App.class);
        logger.trace(&quot;Hello trace!&quot;);
        logger.debug(&quot;Hello debug!&quot;);
        logger.info(&quot;Hello info!&quot;);
        logger.warn(&quot;Hello warn!&quot;);
        logger.error(&quot;Hello error!&quot;);
</code></pre>
<p>控制台输出</p>
<pre><code class="language-shell">16:56:14.662 [main] DEBUG com.example.App - Hello debug!
16:56:14.669 [main] INFO com.example.App - Hello info!
16:56:14.669 [main] WARN com.example.App - Hello warn!
16:56:14.669 [main] ERROR com.example.App - Hello error!
</code></pre>
<p>可以看到除了trace其余等级的日志都打印了出来，为什么trace那么可怜？答案下节揭晓。</p>
<h3 id="配置文件logback">配置文件(Logback)</h3>
<p>SLF4J不过是日志接口而已，要想对日志进行配置，还需要在resources目录下新建一个配置文件。</p>
<pre><code class="language-shell">│   pom.xml
│
├───src
    └───main
        ├───java
        │   └───com
        │       └───example
        │               App.java
        │
        └───resources
                logback.xml
</code></pre>
<p>配置文件格式可以是<code>groovy</code>或<code>xml</code>，笔者不熟悉<code>groovy</code>，所以选择<code>xml</code>格式。</p>
<h4 id="groovy">Groovy</h4>
<p><code>Groovy</code>是一种基于<code>JVM</code> 的敏捷开发语言，它结合了<code>Python</code>、<code>Ruby</code> 和 <code>Smalltalk</code> 的许多强大的特性。既可以作为脚本语言直接解释执行，也可以编译成<code>Java</code>字节码执行，十分强大。<br>
这里不做过多介绍。</p>
<h4 id="xml">XML</h4>
<blockquote>
<p>XML 指可扩展标记语言（e<strong>X</strong>tensible <strong>M</strong>arkup <strong>L</strong>anguage）。<br>
XML 被设计用来传输和存储数据。</p>
</blockquote>
<p><em>logback.xml</em>内容如下</p>
<pre><code class="language-xml">&lt;configuration&gt;

    &lt;appender name=&quot;STDOUT&quot; class=&quot;ch.qos.logback.core.ConsoleAppender&quot;&gt;
        &lt;encoder&gt;
            &lt;pattern&gt;xml %d{HH:mm:ss.SSS} [%thread] %-5level %logger{36} - %msg%n&lt;/pattern&gt;
        &lt;/encoder&gt;
    &lt;/appender&gt;

    &lt;root level=&quot;trace&quot;&gt;
        &lt;appender-ref ref=&quot;STDOUT&quot; /&gt;
    &lt;/root&gt;
&lt;/configuration&gt;
</code></pre>
<h5 id="名词解释">名词解释</h5>
<table>
<thead>
<tr>
<th>名词</th>
<th>意义</th>
</tr>
</thead>
<tbody>
<tr>
<td>configuration</td>
<td>配置</td>
</tr>
<tr>
<td>appender</td>
<td>输出源</td>
</tr>
<tr>
<td>encoder</td>
<td>编码器</td>
</tr>
<tr>
<td>pattern</td>
<td>模式</td>
</tr>
<tr>
<td>layout</td>
<td>布局</td>
</tr>
<tr>
<td>root</td>
<td>根</td>
</tr>
</tbody>
</table>
<p>笔者从<code>logback</code>官方手册中复制了一个最简单的配置，但又有所修改。<br>
文件定义了一个名为<code>STDOUT</code>的<code>appender</code>，又它的<code>class</code>属性可以看出，它是一个向控制台输出的<code>appender</code>。<br>
这个<code>appender</code>的<code>encoder</code>的<code>pattern</code>是<code>xml %d{HH:mm:ss.SSS} [%thread] %-5level %logger{36} - %msg%n</code>。</p>
<h5 id="conversion-word">Conversion Word</h5>
<blockquote>
<p>像%d{HH:mm:ss.SSS}中的{HH:mm:ss.SSS}是代表时间的格式，{}中的内容是转义词的一些属性。<br>
更详细的解释可以看<a href="https://logback.qos.ch/manual/layouts.html#conversionWord">这里</a></p>
</blockquote>
<p>转义词(<em>Conversion Word</em>)表[部分]</p>
<table>
<thead>
<tr>
<th>名词</th>
<th>意义</th>
</tr>
</thead>
<tbody>
<tr>
<td>%d</td>
<td>当前时间</td>
</tr>
<tr>
<td>%thread</td>
<td>当前线程</td>
</tr>
<tr>
<td>%level</td>
<td>当前消息等级</td>
</tr>
<tr>
<td>%logger</td>
<td>当前logger</td>
</tr>
<tr>
<td>%msg</td>
<td>消息内容</td>
</tr>
<tr>
<td>%n</td>
<td>换行</td>
</tr>
</tbody>
</table>
<p>搞懂了<code>%</code>和<code>{}</code>的意义，但这个<code>%-5level</code>中间夹的<code>-5</code>又是怎么回事？</p>
<h5 id="format-modifiers">Format modifiers</h5>
<blockquote>
<p>用格式修饰符可以美观地对齐内容。<br>
点击<a href="https://logback.qos.ch/manual/layouts.html#formatModifiers">这里</a>看更多用法与详解。</p>
</blockquote>
<p>格式修饰符(<em>Format modifiers</em>)表[部分]</p>
<table>
<thead>
<tr>
<th>格式修饰符</th>
<th>左对齐</th>
<th>最小宽度[字符]</th>
<th>最大宽度[字符]</th>
</tr>
</thead>
<tbody>
<tr>
<td>%20logger</td>
<td>否</td>
<td>20</td>
<td>无</td>
</tr>
<tr>
<td>%-20loggerr</td>
<td>是</td>
<td>20</td>
<td>无</td>
</tr>
<tr>
<td>%.30logger</td>
<td>-</td>
<td>无</td>
<td>30</td>
</tr>
</tbody>
</table>
<p>所以，<code>%-5level</code>就是将等级以最小5个字符左对齐。</p>
<p><code>root</code>是配置的根，它的输出等级是<code>trace</code>，<code>root</code>中引用了名为<code>STDOUT</code>的<code>appender</code>。<br>
让我们再运行一次工程。</p>
<pre><code class="language-shell">xml 17:30:34.232 [main] TRACE com.example.App - Hello trace!
xml 17:30:34.234 [main] DEBUG com.example.App - Hello debug!
xml 17:30:34.235 [main] INFO  com.example.App - Hello info!
xml 17:30:34.235 [main] WARN  com.example.App - Hello warn!
xml 17:30:34.235 [main] ERROR com.example.App - Hello error!
</code></pre>
<p>look!!!<br>
每行日志开头都由我们写进<code>pattern</code>的<strong>xml</strong>开头，我们的<code>xml</code>配置文件生效了。而且这一次，<code>trace</code>级别的日志打印出来了！再也不是没人爱了！</p>
<h4 id="输出日志到文件">输出日志到文件</h4>
<p>新增<code>appender</code></p>
<pre><code class="language-xml">&lt;appender name=&quot;FILE&quot; class=&quot;ch.qos.logback.core.FileAppender&quot;&gt;
        &lt;file&gt;myApp.log&lt;/file&gt;
        &lt;encoder&gt;
            &lt;pattern&gt;file %date %level [%thread] %logger{36} [%file:%line] %msg%n&lt;/pattern&gt;
        &lt;/encoder&gt;
    &lt;/appender&gt;
</code></pre>
<p>别忘了在<code>root</code>中引用</p>
<pre><code class="language-xml">&lt;appender-ref ref=&quot;FILE&quot; /&gt;
</code></pre>
<p>运行代码<br>
发现项目目录下出现了myApp.log文件<br>
查看内容</p>
<pre><code class="language-shell">file 2021-07-09 12:53:33,940 TRACE [main] com.example.App [App.java:22] Hello trace!
file 2021-07-09 12:53:33,942 DEBUG [main] com.example.App [App.java:23] Hello debug!
file 2021-07-09 12:53:33,943 INFO [main] com.example.App [App.java:24] Hello info!
file 2021-07-09 12:53:33,943 WARN [main] com.example.App [App.java:25] Hello warn!
file 2021-07-09 12:53:33,948 ERROR [main] com.example.App [App.java:26] Hello error!
</code></pre>
<p>正如我们定义<code>appender</code>一样。</p>
<h2 id="参考资料">参考资料</h2>
<p>[1] <a href="https://baike.baidu.com/item/%E6%97%A5%E5%BF%97/2769135?fr=aladdin">百度百科 日志</a><br>
[2] <a href="https://www.liaoxuefeng.com/wiki/1252599548343744">廖雪峰的官方网站 Java教程</a><br>
[3] <a href="http://www.slf4j.org/">SLF4J官网</a><br>
[4] <a href="https://logback.qos.ch/">Logback官网</a><br>
[5] <a href="https://juejin.cn/post/6844903949598736391#heading-5">Java日志框架：SLF4J详解</a><br>
[6] <a href="https://www.jianshu.com/p/ec3bd614dcb0">SLF4J日志级别以及使用场景</a><br>
[7] <a href="https://www.runoob.com/xml/xml-tutorial.html">XML 教程</a></p>
]]></content>
    </entry>
</feed>